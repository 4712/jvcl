<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0048) -->
<HTML><HEAD><TITLE>Object Pascal Style Guide original by Charles Calvert</TITLE>
<META http-equiv=Content-Type content="text/html; charset=windows-1252">
<link rel="STYLESHEET" href="styles/default.css" type="text/css">
</head>

<BODY>
      <H1>
      Object Pascal Style
      Guide</H1>
      <address>
      <BR> Original by Charles
      Calvert</address>
      <pre>&nbsp;</pre>
            <P><b><font color="#800000">[TODO: change to reflect current JVCL
            coding rules and to refere to JVCL coding examples]</font></b>
      <pre>&nbsp;</pre>
      <P>This article documents a standard style for 
      formatting Delphi code which is to be included in the JEDI Visual Component Library (JVCL). This document is a modified/annotated version of the article 
      originally written by Charles Calvert (with his permission to do so). The 
      original article can be obtained from the Borland <A 
      href="http://community.borland.com/soapbox/techvoyage/article/1,1795,10280,00.html">Community 
      site</A>. As documented elsewhere, it's not necessary for you to format 
      your code according to the rules of this document before submitting it to 
      Project JEDI, although that would be great. Instead the reformatting is 
      done by the JVCL unit owners where necessary. We accept feedback in the 
      form of corrections or suggestions. Send your communications to <A 
      href="mailto:jvcl@delphi-jedi.org?subject=StyleGuide">the JVCL team</A> or 
      <A href="mailto:ccalvert@borland.com?subject=StyleGuide">Charlie 
      Calvert</A>. Note that with a few exceptions this document does not 
      include coding guideliness, only formatting guideliness. A separate 
      document for coding guideliness is in the making.</P>
      <P>&nbsp;</P>
      <P>This article documents a standard style for 
      formatting Delphi code. It is based on the conventions developed by the 
      Delphi team at Borland Software Corporation.</P>
      <P>Object Pascal is a beautifully designed 
      language. One of its great virtues is its readability. These standards are 
      designed to enhance that readability of Object Pascal code. When 
      developers follow the simple conventions laid out in this guide, they will 
      be promoting standards that benefit all Delphi developers by using a 
      uniform style that is easy to read. Efforts to enforce these standards 
      will increase the value of a developer's source code, particularly during 
      maintenance and debugging cycles.</P>
      <P>&nbsp;</P>
      <P>It goes without saying that these are 
      conventions based primarily on matters of taste. Though we believe in, and 
      admire the style promoted in these pages, we support them not necessarily 
      because we believe they are right and others are wrong, but because we 
      believe in the efficacy of having a standard which most developers follow. 
      The human mind adapts to standards, and finds ways to quickly recognize 
      familiar patterns, thereby assimilating meaning quickly and effortlessly. 
      It is the desire to create a standard that will make reading code as 
      simple as possible for the largest number of people that is behind this 
      effort. If at first our guidelines seem strange to you, we ask you to try 
      them for a while, and then we are sure you will grow used to them over 
      time.</P>
      <P>&nbsp;</P>
      <P>Do not post this specification on other web 
      sites. Instead, simply link to either this version of the document or the 
      original one on Charlie's website.</P>
      <P>&nbsp;</P>
      <H2>Contents</H2>
      <p>&nbsp;</p>
      <P>1.0 <A 
      href="#1.0">Introduction</A></P>
      <DL>
        <DD>1.1 <A 
        href="#1.1">Background</A> 

        <DD>1.2 <A 
        href='http://delphi-jedi.org/d"#1.2"'>Acknowledgments</A> 
</DD></DL>
      <P>2.0 <A 
      href="#2.0">Source 
      Files</A></P>
      <DL>
        <DD>2.1 <A 
        href="#2.1">Source-File 
        Naming</A> 
        <DD>2.2 <A 
        href="#2.2">Source-File 
        Organization</A> 
        <DL>
          <DD>2.2.1 <A 
          href="#2.2.2">unit 
          declaration</A> 
          <DD>2.2.2 <A 
          href="#2.2.3">uses 
          declarations</A> 
          <DD>2.2.3 <A 
          href="#2.2.4">class/interface 
          declarations</A> </DD></DL></DD></DL>
      <P>3.0 <A 
      href="#3.0">Naming 
      Conventions</A></P>
      <DL>
        <DD>3.1 <A 
        href="#3.1">Unit 
        Naming</A> 
        <DD>3.2 <A 
        href="#3.2">Class/Interface 
        Naming</A> 
        <DD>3.3 <A 
        href="#3.3">Field 
        Naming</A> 
        <DD>3.4 <A 
        href="#3.4">Method 
        Naming</A> 
        <DD>3.5 <A 
        href="#3.5">Local 
        Variable Naming</A> 
        <DD>3.6 <A 
        href="#3.6">Reserved 
        Words</A> 
        <DD>3.7 <A 
        href="#3.6">Type 
        Declarations</A> </DD></DL>
      <P>4.0 <A 
      href="#4.0">White Space 
      Usage</A></P>
      <DL>
        <DD>4.1 <A 
        href="#4.1">Blank 
        Lines</A> 
        <DD>4.2 <A 
        href="#4.2">Blank 
        Spaces</A> 
        <DL>
          <DD>4.2.1 <A 
          href="#4.2.1">A single 
          blank space (not tab) should be used</A> 
          <DD>4.2.2 <A 
          href="#4.2.2">Blanks 
          should <EM>not</EM> be used</A> </DD></DL>
        <DD>4.3 <A 
        href="#4.3">Indentation</A> 

        <DD>4.4 <A 
        href="#4.4">Continuation 
        Lines</A> </DD></DL>
      <P>5.0 <A 
      href="#5.0">Comments</A></P>
      <DL>
        <DD>5.1 <A 
        href="#5.1">Block 
        Comments</A> 
        <DD>5.2 <A 
        href="#5.2">Single-Line 
        Comments</A> </DD></DL>
      <P>6.0 <A 
      href="#6.0">Classes</A></P>
      <DL>
        <DD>6.1 <A 
        href="#6.1">Class Body 
        Organization</A> 
        <DD>6.2 <A 
        href="#6.2">Method 
        Declarations</A> 
        <DD>6.3 <A 
        href="#6.3">Data Store 
        Declarations</A> </DD></DL>
      <P>7.0 <A 
      href="#7.0">Interfaces</A></P>
      <DL>
        <DD>7.1 <A 
        href="#7.1">Interface 
        Body Organization</A> </DD></DL>
      <P>8.0 <A 
      href="#8.0">Statements</A></P>
      <DL>
        <DD>8.1 <A 
        href="#8.1">Simple 
        Statements</A> 
        <DL>
          <DD>8.1.1 <A 
          href="#8.1.1">Assignment 
          and expression statements</A> 
          <DD>8.1.2 <A 
          href="#8.1.2">Local 
          variable declarations</A> 
          <DD>8.1.3 <A 
          href="#8.1.3">Array 
          declarations</A> </DD></DL>
        <DD>8.2 <A 
        href="#8.2">Compound 
        Statements</A> 
        <DL>
          <DD>8.2.3 <A 
          href="#8.2.3">if 
          statement</A> 
          <DD>8.2.4 <A 
          href="#8.2.4">for 
          statement</A> 
          <DD>8.2.5 <A 
          href="#8.2.5">while 
          statement</A> 
          <DD>8.2.6 <A 
          href="#8.2.6">repeat 
          until statement</A> 
          <DD>8.2.7 <A 
          href="#8.2.7">case 
          statement</A> 
          <DD>8.2.8 <A 
          href="#8.2.8">try 
          statement</A> </DD></DL></DD></DL>
      <P>9.0 <A 
      href="#9.0">Miscellanous</A></P>
      <DL>
        <DD>9.1 <A 
        href="#9.1">Const, Var 
        and Type</A> 
        <DD>9.2 <A 
        href="#9.2">Conditional 
        compilation</A> 
        <DD>9.3 <A 
        href="#9.3">Resource 
        strings</A> 
        <DD>9.4 <A 
        href="#9.4">Exceptions</A> 

        <DD>9.5 <A 
        href="#9.5">Categories 
        and routine separation</A> 
        <DD>9.6 <A 
        href="#9.6">Assembler</A> 

        <DD>9.7 <A 
        href="#9.7">Local 
        routines</A> 
        <DD>9.8 <A 
        href="#9.8">Parameter 
        Declarations</A> 
        <DD>9.9 <A 
        href="#9.9">Initialization 
        of global variables</A> </DD></DL>
      <H2><A name=1.0></A>1.0 Introduction</H2>
      <P>This document is not an attempt to define a 
      grammar for the Object Pascal language. For instance, it is illegal to 
      place a semicolon before an else statement; the compiler simply won't let 
      you do it. As a result, I do not lay that rule out in this style guide. 
      This document is meant to define the proper course of action in places 
      where the language gives you a choice. I usually remain mute on matters 
      that can only be handled one way.</P>
      <H5><A name=1.1></A>1.1 Background</H5>
      <P>The guidelines presented here are based on 
      the public portions of the Delphi source. The Delphi source should follow 
      these guidelines precisely. If you find cases where the source varies from 
      these guidelines, then these guidelines, and not the errant source code, 
      should be considered your standard. Nevertheless, you should use the 
      source as a supplement to these guidelines, at least so far as it can help 
      you get a general feel for how your code should look.</P>
      <H5><A name=1.2></A>1.2 
      Acknowledgments</H5>
      <P>The format of this document and some of its 
      language is based on work done to define a style standard for the Java 
      language. Java has had no influence on the rules for formatting Object 
      Pascal source, but documents found on the Sun web site formed the basis 
      for this document. In particular the style and format of this document 
      were heavily influenced by "A Coding Style Guide for Java WorkShop and 
      Java Studio Programming" by Achut Reddy. That document can be found at the 
      following URL: <A 
      href="http://www.sun.com/workshop/java/wp-coding">http://www.sun.com/workshop/java/wp-coding</A></P>
      <P>&nbsp;</P>
      <P>The Delphi team at Borland software 
      corporation also contributed heavily to the generation of this document, 
      and indeed, it would not have been possible to create it without their 
      help.</P>
      <P>&nbsp;</P>
      <P>Many of the modifications to this document where at least partly based on feedback by Marcel van Brakel and Mike 
      Lischke. Other people who contributed are Robert Marquardt and Matthias 
      Thoma.</P>
      <H2>&nbsp;</H2>
      <H2><A name=2.0></A>2.0 Source Files</H2>
      <P>Object Pascal source is divided up primarily 
      into units and Delphi Project files, which both follow the same 
      conventions. A Delphi Project file has a DPR extension. It is the main 
      source file for a project. Any units used in the project will have a PAS 
      extension. Additional files, such as batch files, html files, or DLLs, may 
      play a role in a project, but this paper only treats the formatting of DPR 
      and PAS files.</P>
      <H5><A name=2.1></A>2.1 Source-File 
      Naming</H5>
      <P>Object Pascal supports long file names. If 
      you are appending several words to create a single name, then it is best 
      to use capital letters for each word in the name: MyFile.pas. This is 
      known as InfixCaps, or Camel Caps. Extensions should be in lower case. For 
      historical reasons, the Delphi source itself often confines itself to 8:3 
      naming patterns, but developers no longer need feel constrained by those 
      limits, even if turning in source that might be used by the Delphi 
      team.</P>
      <P>&nbsp;</P>
      <P>If you are translating a C/C++ header file, 
      then your Pascal header translation will usually have the same name as the 
      file you are translating, except it should have a PAS extension. For 
      instance, Windows.h would become Windows.pas. If the rules of Pascal 
      grammar force you to combine multiple header files into a single unit, 
      then use the name of the base unit into which you are folding the other 
      files. For instance, if you fold WinBase.h into Windows.h, then call the 
      resulting file Windows.pas.</P>
      <P>&nbsp;</P>
      <P>All JEDI Visal Component Library source-files must be 
      prefixed with 'Jv'. Also, since these files are to be ported to Linux be 
      carefull that you use the same capitalization everywhere a source-file is 
      referenced (Linux filenames are, as opposed to Win32, case-sensitive).</P>
      <H5><A name=2.2></A>2.2 Source-File 
      Organization</H5>
      <P>All Object Pascal units should contain the 
      following elements in the following order:</P>
      <P>&nbsp;</P>
      <OL>
        <LI>
        <P>Copyright/ID
        block comment</P>
        <LI>
        <P>Unit 
        Name</P>
        <LI>
        <P>Include 
        files</P>
        <LI>
        <P>Interface 
        section</P>
        <LI>
        <P>Additional 
        defines</P>
        <LI>
        <P>Uses 
        clause</P>
        <LI>
        <P> 
        Implementation</P>
        <LI>
        <P>Uses 
        clause</P>
        <LI>
        <P>A closing end and a 
      period.</P></LI>
        <LI>
      <P>At least one blank line should separate each 
      of these elements.</P>
        <P>&nbsp;</P></LI></OL>
      <P>&nbsp;</P>
      <P>Additional elements can be structured in the 
      order you find most appropriate, except that the top of the file should 
      always list the copyright first, the unit name second, then any 
      conditional defines, compiler directives or include statements, then the 
      uses clause. For the JVCL the following header is used. Replace JvGraphics 
      with the appropriate unit name. The Last Modified date is kept up to date 
      by the unit owner and should always match the last modified date in the 
      filesystem.</P>
      <P>&nbsp;</P><PRE>{******************************************************************************}
{                                                                              }
{ Project JEDI Code Library (JVCL)                                              }
{                                                                              }
{ The contents of this file are subject to the Mozilla Public License Version  }
{ 1.0 (the &quot;License&quot;); you may not use this file except in compliance with the }
{ License. You may obtain a copy of the License at http://www.mozilla.org/MPL/ }
{                                                                              }
{ Software distributed under the License is distributed on an &quot;AS IS&quot; basis,   }
{ WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for }
{ the specific language governing rights and limitations under the License.    }
{                                                                              }
{ The Original Code is JVCLGraphics.pas.                                        }
{                                                                              }
{ The Initial Developer of the Original Code is documented in the accompanying }
{ help file JVCL.chm. Portions created by these individuals are Copyright (C)   }
{ 2000 of these individuals.                                                   }
{                                                                              }
{ Contains various graphics related classes and subroutines such as a Win32    }
{ regions encapsulatiion, a very fast TBitmap replacement and various          }
{ transformation and filtering routines.                                       }
{                                                                              }
{ Unit owner:    Wim de Cleen                                                  }
{ Last modified: June 7, 2000                                                  }
{                                                                              }
{******************************************************************************}

unit Buttons;</PRE>
      <P>&nbsp;</P>
      <P>Compiler directives are not directly included 
      in the source files. Instead a global JVCL.INC include file is used which 
      defines all standard directives. Ex.</P><PRE>&nbsp;</PRE>
      <PRE>{$I JVCL.INC}

interface</PRE>
      <P>&nbsp;</P>
      <P>If overriding directives are needed they can 
      be included below this include but this must be avoided. If overriding 
      directives are needed these must be documented. You should strive to 
      override directives only a local scope. For example, for a single 
      procedure.</P><PRE>&nbsp;</PRE>
      <PRE>{$S-,W-,R-}
{$C PRELOAD}

interface

uses
  Windows, Messages, Classes, Controls, Forms, Graphics, StdCtrls, ExtCtrls, CommCtrl;</PRE>
      <P>&nbsp;</P>
      <P>It does not matter if you place a type 
      section before a const section, or if you mix type and const sections up 
      in any order you choose.</P>
      <P>The implementation should list the word 
      implementation first, then the uses clause, then any include statements or 
      other directives:</P><PRE>implementation

uses
  Consts, SysUtils, ActnList, ImgList;

{$R BUTTONS.RES}</PRE>
      <H5><A name=2.2.2></A>2.2.1 Unit 
      declaration</H5>
      <P>Every source file should contain a unit 
      declaration. The word unit is a reserved word, so it should be in lower 
      case. The name of the unit should be in mixed upper and lowercase, and 
      must be the same as the name used by the operating system's file system.
      Example:</P><PRE>&nbsp;</PRE>
      <PRE>unit MyUnit;</PRE>
      <P>&nbsp;</P>
      <P>This unit would be called MyUnit.pas when an
      entry is placed in the file system.</P>
      <H5><A name=2.2.3></A>2.2.2 uses declarations</H5>
      <P>Inside units, a uses declaration should begin 
      with the word uses, in lowercase. Add the names of the units, following 
      the capitalization conventions used in the declaration found inside the 
      units:</P><PRE>&nbsp;</PRE>
      <PRE>uses MyUnit;</PRE>
      <P>&nbsp;</P>
      <P>Each unit must be separated from its neighbor 
      by a comma, and the last unit should have a semicolon after it:</P><PRE>&nbsp;</PRE>
      <PRE>uses
  Windows, SysUtils, Classes, Graphics, Controls, Forms, TypInfo; </PRE>
      <PRE>&nbsp;</PRE>
      <P>The uses clause is always started on the next 
      line and units are written down one after another, wrapping at 100 
      columns. Furthermore, you should separate the standard Delphi units, JVCL units and Platform dependent units. Finally, it is prefered to list to 
      units in alpabetical order unless the order is important (this should 
      never be the case but sometimes is, an example is the Windows unit which - 
      by convention - should always be listed first). An example follows 
      (comments shouldn't be included):</P><PRE>&nbsp;</PRE>
      <PRE>uses
  {$IFDEF WIN32}
  Windows, ActiveX,    // Windows units
  {$ENDIF}
  {$IFDEF LINUX}
  ..Linux specific units go here
  {$ENDIF}
  Math, SysUtils,      // Standard Delphi platform independent units
  JVCLBase, JVCLStrings; // JVCL units</PRE>
      <H5><A name=2.2.4></A>2.2.3 class/interface 
      declarations</H5>
      <P>A class declaration begins with two spaces, 
      followed by an identifier prefaced by a capital T. Identifiers should 
      begin with a capital letter, and should have capital letters for each 
      embedded word (InfixCaps). Never use tab characters in your Object Pascal 
      source. Example:</P><PRE>&nbsp;</PRE>
      <PRE>TMyClass</PRE>
      <P>&nbsp;</P>
      <P>Follow the identifier with a space, then an 
      equals sign, then the word class (all in lower case), furthermore a 
      parenthesis, the name of the ancestor class, and closing parenthesis. The 
      class keyword and ancestor should be separated with a space:</P>
      <P>&nbsp;</P>
      <P>TMyClass = class (TObject)</P>
      <P>&nbsp;</P>
      <P>Scoping directives should be two spaces in 
      from the margin, and declared in the order shown in this 
      example:</P><PRE>&nbsp;</PRE>
      <PRE>  TMyClass = class (TObject)
  private
  protected
  public
  published
  end;</PRE>
      <P>&nbsp;</P>
      <P>Data should always be declared only in the 
      private section, and its identifier should be prefaced by an F. All type 
      declarations should be four spaces in from the margin:</P><PRE>&nbsp;</PRE>
      <PRE>  TMyClass = class (TObject)
  private
    FMyData: Integer;
    function GetData: Integer;
    procedure SetData(Value: Integer);
  public
  published
    property MyData: Integer read GetData write SetData;
  end;</PRE>
      <P>&nbsp;</P>
      <P><A 
      href="#7.0">Interfaces</A> 
      follow the same rules as class declarations, except you should omit any 
      scoping directives or private data, and should use the word interface 
      rather than class.</P>
      <H2>&nbsp;</H2>
      <H2><A name=3.0></A>3.0 Naming 
      Conventions</H2>
      <P>Except for reserved words and directives, 
      which are in all lowercase, all Pascal identifiers should use InfixCaps, 
      which means the first letter should be a capital, and any embedded words 
      in an identifier should be in caps, as well as any acronym that is 
      embedded:</P><PRE>&nbsp;</PRE>
      <PRE>MyIdentifier MyFTPClass</PRE>
      <P>&nbsp;</P>
      <P>The major exception to this rule is in the 
      case of header translations, which should always follow the conventions 
      used in the header. For instance, write WM_LBUTTONDOWN, not 
      wm_LButtonDown.</P>
      <P>&nbsp;</P>
      <P>Except in header translations, do not use 
      underscores to separate words. Class names should be nouns or noun 
      phrases. Interface or class names depend on the salient purpose of the 
      interface.</P>
      <P>&nbsp;</P>
      <P>GOOD type names:</P>
      <DL>
        <DD>AddressForm 
        <DD> 
        ArrayIndexOutOfBoundsException </DD></DL>
      <P>BAD type names:</P>
      <DL>
        <DD>ManageLayout (verb phrase) 
        <DD> 
        delphi_is_new_to_me (underscores) </DD></DL>
      <P>It seems to be unavoidable but every now and 
      then someone suggests using hungarian, or a similar, notation for 
      identifier naming. Although good arguments can be provided in favor of 
      hungarian notation, at least as many arguments can be given against it. 
      The JVCL will not use hungarian notation, ever! There, that's out of the 
      way. Identifiers in the JVCL should be named as the examples above, names 
      which describe the purpose of the identifier not what type they happen to 
      be of.</P>
      <H5><A name=3.1></A>3.1 Unit Naming</H5>
      <P>Use InfixCaps, as described at the beginning 
      of this section. See also the section on <A 
      href="#2.2.2">unit 
      declarations</A></P>
      <P>&nbsp;</P>
      <P>As described earlier, all JVCL units should 
      have the &quot;Jv&quot; prefix.</P>
      <H5><A name=3.2></A>3.2 Class/Interface 
      Naming</H5>
      <P>Use InfixCaps, as described at the beginning 
      of this section. Begin each type declaration with a capital T:</P><PRE>&nbsp;</PRE>
      <PRE>TMyType</PRE>
      <P>&nbsp;</P>
      <P>See also the section on <A 
      href="#2.2.4">class/interface 
      declarations.</A></P>
      <P>&nbsp;</P>
      <P>All JVCL classes are prefixed with 'TJVCL' not 
      just a capital T. Types which are used only internally don't have to 
      include the 'JVCL' prefix although you should be carefull with the naming 
      when they are declared in the interface section.</P>
      <H5><A name=3.3></A>3.3 Field Naming</H5>
      <P>Use InfixCaps, as described at the beginning 
      of this section. Begin each type declaration with a capital F, and declare 
      all data types in the private section, using properties or getters and 
      setters to provide public access. For example, use the name GetSomething 
      to name a function returning an internal field value and use SetSomething 
      to name a procedure setting that value.</P>
      <P>&nbsp;</P>
      <P>Do not use all caps for const declarations 
      except where required in header translations.</P>
      <P>&nbsp;</P>
      <P>Delphi is created in California, so we 
      discourage the use of hungarian notation, except where required in header 
      translations:</P><PRE>&nbsp;</PRE>
      <PRE>CORRECT
  FMyString: string;

INCORRECT
  lpstrMyString: string;</PRE>
      <P>&nbsp;</P>
      <P>The exception to the Hungarian notation rule 
      is in enumerated types.</P><PRE>&nbsp;</PRE>
      <PRE>  TBitBtnKind = (bkCustom, bkOK, bkCancel, bkHelp,
    bkYes, bkNo, bkClose, bkAbort, bkRetry,
    bkIgnore, bkAll);</PRE>
      <P>&nbsp;</P>
      <P>In this case the letters bk are inserted 
      before each element of this enumeration. bk stands for 
      ButtonKind.</P>
      <P>When thinking about naming conventions, 
      consider that one-character field names should be avoided except for 
      temporary and looping variables.</P>
      <P>Looping variables are by convention named I 
      (capital i) and J. Other commonly used single character identifier names 
      are: S (string) and R (Result). Single letter variables/field names should 
      always be capitals but other then the ones mentioned above you should 
      avoid them and use more meaningful names.</P>
      <P>Avoid variable l ("el") because it is hard to 
      distinguish it from 1 ("one") on some printers and displays.</P>
      <H5><A name=3.4></A>3.4 Method 
Naming</H5>
      <P>Method names should use the InfixCaps style. 
      Start with a capital letter, and capitalize the first letter of any 
      subsequent word in the name, as well as any letters that are part of an 
      acronym. All other characters in the name are lower case. Do not use 
      underscores to separate words. Note that this is identical to the naming 
      convention for non-constant fields; however it should always be easy to 
      distinguish the two from context. Method names should be imperative verbs 
      or verb phrases.</P>
      <P>&nbsp;</P>
      <P>Examples:</P>
      <DL>
        <DD>&nbsp;
        <DD><B><I>Good method names:</I></B> 
        <DL>
          <DD>ShowStatus 
          <DD>DrawCircle 
          <DD>AddLayoutComponent </DD></DL>
        <DD><B><I>Bad method names:</I></B> 
        <DL>
          <DD>MouseButton (noun phrase; doesn't 
          describe function) 
          <DD>drawCircle (starts with lower-case 
          letter) 
          <DD>add_layout_component 
          (underscores) 
          <DD>
          ServerRunning (verb phrase, but not imperative) 
        </DD></DL></DD></DL>
      <P>A note about the last example 
      (ServerRunning): The function of this method is unclear. Does it start the 
      server running (better: StartServer), or test whether or not it is running 
      (better: IsServerRunning)?</P>
      <P>&nbsp;</P>
      <P>A method to get or set some property of the 
      class should be called GetProperty or SetProperty respectively, where 
      Property is the name of the property.</P>
      <P>&nbsp;</P>
      <P>Examples:</P><PRE>&nbsp;</PRE>
      <PRE>GetHeight, SetHeight</PRE>
      <P>&nbsp;</P>
      <P>A method to test some boolean property of the 
      class should be called IsVisible, where Visible is the name of the 
      property.</P>
      <P>&nbsp;</P>
      <P>Examples:</P><PRE>&nbsp;</PRE>
      <PRE>IsResizable, IsVisible</PRE>
      <H5><A name=3.5></A>3.5 Local Variable 
      Naming</H5>
      <P>Local variables follow the same naming rules 
      as field names, except you omit the initial F, since this is not a Field 
      of an object. (see <A 
      href="#3.3">section 
      3.3</A>).</P>
      <H5><A name=3.6></A>3.6 Reserved 
      Words</H5>
      <P>Reserved words and directives should be all 
      lowercase. This can be a bit confusing at times. For instance types such 
      as Integer are just identifiers, and appear with a first cap. Strings, 
      however, are declared with the reserved word string, which should be all 
      lowercase.</P>
      <H5><A name=3.7></A>3.7 Type 
      Declarations</H5>
      <P>All type declarations should begin with the 
      letter T, and should follow the same capitalization specification laid out 
      in the <A 
      href="#3.0">beginning</A> 
      of this section, or in the section on <A 
      href="#2.2.4">class 
      declarations.</A></P>
      <P>&nbsp;</P>
      <H2><A name=4.0></A>4.0 White Space 
      Usage</H2>
      <H5><A name=4.1></A>4.1 Blank Lines</H5>
      <P>Blank lines can improve readability by 
      grouping sections of the code that are logically related. A blank line 
      should also be used in the following places:</P>
      <P>&nbsp;</P>
      <OL>
        <LI>
        <P>After the copyright block comment, package declaration, and import section.</P>
        <LI>
        <P>Between class 
        declarations.</P>
        <LI>
        <P>Between method 
      declarations.</P></LI></OL>
      <H5><A name=4.2></A>4.2 Blank Spaces</H5>
      <P>Object Pascal is a very clean, easy to read 
      language. In general, you don't need to add a lot of spaces in your code 
      to break up lines. The next few sections give you some guidelines to 
      follow when placing spaces in your code.</P>
      <H5><A name=4.2.2></A>4.2.2 Blanks should 
      <EM>not</EM> be used:</H5>
      <OL>
        <LI>
        <P>Between a method 
        name and its opening parenthesis.</P>
        <LI>
        <P>Before or after 
        a .(dot) operator.</P>
        <LI>
        <P>Between a unary 
        operator and its operand.</P>
        <LI>
        <P>Between a cast 
        and the expression being cast.</P>
        <LI>
        <P>After an opening 
        parenthesis or before a closing parenthesis.</P>
        <LI>
        <P>After an opening 
        square bracket [ or before a closing square bracket ].</P>
        <LI>
        <P>Before a semicolon.</P></LI></OL>
      <P>&nbsp;</P>
      <P>Examples of correct usage:</P><PRE>&nbsp;</PRE>
      <PRE>function TMyClass.MyFunc(var Value: Integer);
MyPointer := @MyRecord;
MyClass := TMyClass(MyPointer);
MyInteger := MyIntegerArray[5];</PRE>
      <P>Examples of incorrect usage:</P><PRE>function TMyClass.MyFunc( var Value: Integer ) ;
MyPointer := @ MyRecord;
MyClass := TMyClass ( MyPointer ) ;
MyInteger := MyIntegerArray [ 5 ] ;</PRE>
      <H5><A name=4.3></A>4.3 Indentation</H5>
      <P>You should always indent two spaces for all 
      indentation levels. In other words, the first level of indentation is two 
      spaces, the second level four spaces, the third level 6 spaces, etc. Never 
      use tab characters.</P>
      <P>&nbsp;</P>
      <P>There are few exceptions. The reserved words 
      unit, uses, type, interface, implementation, initialization and 
      finalization should always be flush with the margin. The final end 
      statement at the end of a unit should be flush with the margin. In the 
      project file, the word program, and the main begin and end block should 
      all be flush with the margin. The code inside the begin..end block, should 
      be indented at least two spaces.</P>
      <H5><A name=4.4></A>4.4 Continuation 
      Lines</H5>
      <P>Lines should be limited to 100 columns. Lines 
      longer than 100 columns should be broken into one or more continuation 
      lines, as needed. All the continuation lines should be aligned and 
      indented from the first line of the statement, and indented two 
      characters. Always place begin statements on their own line.</P>
      <P>&nbsp;</P>
      <P>Examples:</P><PRE>&nbsp;</PRE>
      <PRE>// CORRECT

function CreateWindowEx(dwExStyle: DWORD;
  lpClassName: PChar; lpWindowName: PChar;
  dwStyle: DWORD; X, Y, nWidth, nHeight: Integer;
  hWndParent: HWND; hMenu: HMENU; hInstance: HINST;
  lpParam: Pointer): HWND; stdcall;


if ((X = Y) or (Y = X) or
  (Z = P) or (F = J) then
begin
  S := J;
end;</PRE>
      <P>&nbsp;</P>
      <P>Never wrap a line between a parameter and its 
      type, unless it is a comma separated list, then wrap at least before the 
      last parameter so the type name follows to the next line. The colon for 
      all variable declarations contains no whitespace between it and the 
      variable. There should be a single space following the colon before the 
      type name;</P>
      <P>&nbsp;</P><PRE>procedure Foo(Param1: Integer; Param2: Integer);


procedure Foo( Param :Integer; Param2:Integer );</PRE>
      <P>&nbsp;</P>
      <P>A continuation line should never start with a 
      binary operator. Avoid breaking a line where normally no white space 
      appears, such as between a method name and its opening parenthesis, or 
      between an array name and its opening square bracket. If you must break 
      under these circumstances, then one viable place to begin is after the 
      opening parenthesis that follows a method name. Never place a begin 
      statement on the same line with any other code.</P>
      <P>&nbsp;</P>
      <P>Examples:</P>
      <P>&nbsp;</P><PRE>// INCORRECT
while (LongExpression1 or LongExpression2) do begin
  // DoSomething
  // DoSomethingElse;
end;

// CORRECT
while (LongExpression1 or LongExpression2) do 
begin
  // DoSomething
  // DoSomethingElse;
end;

if (LongExpression1)  
   or (LongExpression2) 
   or (LongExpression3) then
// CORRECT
if (LongExpression1) or 
  (LongExpression2) or 
  (LongExpression3) then 
  </PRE>
      <H2><A name=5.0></A>5.0 Comments</H2>
      <P>The Object Pascal language supports two kinds 
      of comments: block, and single-line comments. Some general guidelines for 
      comment usage include:</P>
      <P>&nbsp;</P>
      <UL>
        <LI>
        <P>It is helpful to 
        place comments near the top of unit to explain its purpose.</P>
        <LI>
        <P>It is helpful to 
        place comments before a class declaration.</P>
        <LI>
        <P>It is helpful to 
        place comments before some method declarations.</P>
        <LI>
        <P>Avoid making obvious 
        comments:</P></LI></UL><PRE>&nbsp;</PRE>
      <PRE>i := i + 1;     // Add one to i</PRE>
      <PRE>&nbsp;</PRE>
      <UL>
        <LI>
        <P>Remember that 
        misleading comments are worse than no comments at all.</P>
        <LI>
        <P>Avoid putting 
        any information into comments that is likely to become out of 
        date.</P>
        <LI>
        <P>Avoid enclosing 
        comments in boxes drawn with asterisks or other special 
        typography.</P>
        <LI>
        <P>Temporary comments that are expected to be 
        changed or removed later should be marked with the special tag "TODO:" 
        so that they can easily be found afterwards. Ideally, all temporary 
        comments should have been removed by the time a program is ready to be 
        shipped.</P></LI></UL>
      <P>&nbsp;</P>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>// TODO: Change this to call Sort when it is fixed
List.MySort;</PRE>
      <h5><A name=5.1></A>5.1 Block Comments</h5>
      <P>&nbsp;</P>
      <P>Object Pascal supports two types of block 
      comments. The most commonly used block comment is a pair of curly braces: 
      { }. The Delphi team prefers to keep comments of this type as spare and 
      simple as possible. For instance, you should avoid using asterisks to 
      create patterns or lines inside your comments. Instead, make use of white 
      space to break your comments up, much as you would in a word processing 
      document. The words in your comments should start on the same line as the 
      first curly brace, as shown in this excerpt from DsgnIntf.pas:</P>
      <P>&nbsp;</P><PRE>{ TPropertyEditor

  Edits a property of a component, or list of components,
  selected into the Object Inspector.  The property
  editor is created based on the type of the
  property being edited as determined by the types
  registered by...

  etc...

    GetXxxValue
      Gets the value of the first property in the
      Properties property.  Calls the appropriate
      TProperty GetXxxValue method to retrieve the
      value.

    SetXxxValue Sets the value of all the properties
      in the Properties property.  Calls the appropriate
      TProperty SetXxxxValue methods to set the value. }</PRE>
      <PRE>&nbsp;</PRE>
      <P>A block comment is always used for the 
      copyright/ID comment at the beginning of each source file. It is also used 
      to "comment out" several lines of code.</P>
      <P>Block comments used to describe a method 
      should appear before the method declaration.</P>
      <P>&nbsp;</P>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>// CORRECT

{ TMyObject.MyMethod

  This routine allows you to execute code. }

procedure TMyObject.MyMethod;
begin
end;


procedure TMyObject.MyMethod;
{******************************************************
  TMyObject.MyMethod

  This routine allows you to execute code.
*******************************************************}
begin
end;</PRE>
      <PRE>&nbsp;</PRE>
      <P>A second kind of block comment contains two 
      characters, a parenthesis and an asterisk: (* *). This is sometimes called 
      starparen comments. These comments are generally useful only during code 
      development, as their primary benefit is that they allow nesting of 
      comments, as long as the nest level is less than 2. Object Pascal doesn't 
      support nesting comments of the same type within each other, so really 
      there is only one level of comment nesting: curly inside of starparen, and 
      starparen inside of curly. As long as you don't nest them, any other 
      standard Pascal comments between comments of this type will be ignored. As 
      a result, you can use this syntax to comment out a large chunk of code 
      that is full of mixed code and comments:</P>
      <P>&nbsp;</P><PRE>(* procedure TForm1.Button1Click(Sender: TObject);
begin
  DoThis; // Start the process
  DoThat; // Continue iteration
  { We need a way to report errors here, perhaps using
    a try finally block ??? }
  CallMoreCode; // Finalize the process
end; *)</PRE>
      <PRE>&nbsp;</PRE>
      <P>In this example, the entire Button1Click 
      method is commented out, including any of the subcomments found between 
      the procedure's begin..end pair.</P>
      <H5><A name=5.2></A>5.2 Single-Line 
      Comments</H5>
      <P>A single-line comment consists of the 
      characters // followed by text. Include a single space between the // and 
      the comment itself. Place single line comments at the same indentation 
      level as the code that follows it. You can group single-line comments to 
      form a larger comment.</P>
      <P>A single-line comment or comment group should 
      always be preceded by a blank line, unless it is the first line in a 
      block. If the comment applies to a group of several statements, then the 
      comment or comment group should also be followed by a blank line. If it 
      applies only to the next statement (which may be a compound statement), 
      then do not follow it with a blank line.</P>
      <P>&nbsp;</P>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>Table1.Open;</PRE>
      <PRE>&nbsp;</PRE>
      <P>Single-line comments can also follow the code 
      they reference. These comments, sometimes referred to as trailing 
      comments, appear on the same line as the code they describe. They should 
      have at least one space-character separating them from the code they 
      reference. If more than one trailing comment appears in a block of code, 
      they should all be aligned to the same column.</P>
      <P>&nbsp;</P>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>if (not IsVisible) then
  Exit;          // nothing to do
Inc(StrLength);  // reserve space for null terminator</PRE>
      <PRE>&nbsp;</PRE>
      <P>Avoid commenting every line of executable 
      code with a trailing comment. It is usually best to limit the comments 
      inside the begin..end pair of a method or function to a bare minimum. 
      Longer comments can appear in a block comment before the method or 
      function declaration.</P>
      <P>&nbsp;</P>
      <H2><A name=6.0></A>Classes</H2>
      <H5><A name=6.1></A>6.1 Class Body 
      Organization</H5>
      <P>The body of a class declaration should be 
      organized in the following order:</P>
      <P>&nbsp;</P>
      <UL>
        <LI>
        <P>Field 
        declarations</P>
        <LI>
        <P>Method 
        declarations</P>
        <LI>
        <P>Property declarations</P></LI></UL>
        <P>&nbsp;</P>
      <P>The fields, properties and methods in your 
      class should be arranged alphabetically by name.</P>
      <H5><A name=6.1.1></A>6.1.1 Access 
      levels</H5>
      <P>Except for code inserted by the IDE, the 
      scoping directives for a class should be declared in the following 
      order:</P>
      <P>&nbsp;</P>
      <UL>
        <LI>
        <P>Private 
        declarations</P>
        <LI>
        <P>Protected 
        declarations</P>
        <LI>
        <P>Public 
        declarations</P>
        <LI>
        <P>Published declarations</P></LI></UL>
        <P>&nbsp;</P>
      <P>There are <EM>four</EM> access levels for 
      class members in Object Pascal: published, public, protected, and private 
      -- in order of decreasing accessibility. By default, the access level is 
      published. In general, a member should be given the lowest access level 
      which is appropriate for the member. For example, a member which is only 
      accessed by classes in the same unit should be set to <EM>private</EM> 
      access. Also, declaring a lower access level will often give the compiler 
      increased opportunities for optimization. On the other hand, use of 
      private makes it difficult to extend the class by sub-classing. If there 
      is reason to believe the class might be sub-classed in the future, then 
      members that might be needed by sub-classes should be declared protected 
      instead of private, and the properties used to access private data should 
      be given protected status.</P>
      <P>You should never allow public access to data. 
      Data should always be declared in the private section, and any public 
      access should be via getter and setter methods, or properties.</P>
      <H5><A name=6.1.8></A>6.1.8 Constructor 
      declarations</H5>
      <P>Methods should be arranged alphabetically. It 
      is correct either to place your constructors and destructors at the head 
      of this list in the public section, or to arrange them in alphabetical 
      order within the public section.</P>
      <P>&nbsp;</P>
      <P>If there is more than one constructor, and if 
      you choose to give them all the same name, then sort them lexically by 
      formal parameter list, with constructors having more parameters always 
      coming after those with fewer parameters. This implies that a constructor 
      with no arguments (if it exists) is always the first one. For greatest 
      compatibility with C++Builder, try to make the parameter lists of your 
      constructors unique. C++ cannot call constructors by name, so the only way 
      to distinguish between multiple constructors is by parameter 
      list.</P>
      <H5><A name=6.2></A>6.2 Method 
      Declarations</H5>
      <P>If possible, a method declaration should 
      appear on one line.</P>
      <P>&nbsp;</P>
      <P>Examples:</P>
      <P>&nbsp;</P><PRE>procedure ImageUpdate(Image img, infoflags: Integer,
  x: Integer, y: Integer, w: Integer, h: Integer)</PRE>
      <PRE>&nbsp;</PRE>
      <H2><A name=7.0></A>Interfaces</H2>
      <P>Interfaces are declared in a manner that runs 
      parallel to the declaration for classes:</P>
      <P>&nbsp;</P><PRE>InterfaceName = interface([Inherited Interface])
InterfaceBody
end;</PRE>
      <PRE>&nbsp;</PRE>
      <ul>
        <li>An interface declaration should be indented 
      two spaces. The <EM>body</EM> of the interface is indented by the standard 
      indentation of four spaces. The closing end statement should also be 
      indented two characters. There should be a semi-colon following the 
      closing end statement.</li>
        <li>&nbsp;</li>
        <li>There are no fields in an interface 
      declaration. Properties, however, are allowed.</li>
        <li>&nbsp;</li>
        <li>All interface methods are inherently public 
      and abstract; do not explicitly include these keywords in the declaration 
      of an interface method.</li>
        <li>&nbsp;</li>
        <li>Except as otherwise noted, interface 
      declarations follow the same style guidelines as classes.</li>
      </ul>
      <H5><A name=7.1></A>7.1 Interface Body 
      Organization</H5>
      <P>The body of an interface declaration should 
      be organized in the following order:</P>
      <P>&nbsp;</P>
      <OL>
        <LI>
        <P>Interface method 
        declarations</P>
        <LI>
        <P>Interface property 
        declarations</P></LI></OL>
        <P>&nbsp;</P>
      <P>The declaration styles of interface 
      properties and methods are identical to the styles for class properties 
      and methods.</P>
      <P>&nbsp;</P>
      <H2><A name=8.0></A>8.0 Statements</H2>
      <P>Statements are one or more lines of code 
      followed by a semicolon. Simple statements have one semicolon, while 
      compound statements have more than one semicolon and therefore consist of 
      multiple simple statements.</P>
      <P>&nbsp;</P>
      <P>Here is a simple statement:</P><PRE>&nbsp;</PRE>
      <PRE>A := B; </PRE>
      <P>&nbsp;</P>
      <P>Here is a compound, or structured, 
      statement:</P><PRE>&nbsp;</PRE>
      <PRE>begin
  B := C;
  A := B;
end;</PRE>
      <PRE>&nbsp;</PRE>
      <H2><A name=8.0.1></A>8.0.1 Simple 
      Statements</H2>
      <P>A simple statement contains a single 
      semicolon. If you need to wrap the statement, indent the second line two 
      spaces in from the previous line:</P>
      <P>&nbsp;</P><PRE>MyValue :=
  MyValue + (SomeVeryLongStatement / OtherLongStatement);</PRE>
      <PRE>&nbsp;</PRE>
      <H2><A name=8.0.2></A>8.0.1 Compound 
      Statements</H2>
      <P>Compound Statements always end with a 
      semicolon, even if it is syntactically not required. For example the last 
      statement in the following example must have a terminating semicolon for 
      it to be acceptable in the JVCL.</P><PRE>&nbsp;</PRE>
      <PRE>begin
  MyStatement;
  MyNextStatement;
  MyLastStatement;   // semicolon optional
end;</PRE>
      <PRE>&nbsp;</PRE>
      <P><A name=8.1.1></A><B>8.1.1 Assignment and 
      expression statements</B></P>
      <P>&nbsp;</P>
      <P>Each line should contain at most one 
      statement. For example:</P>
      <P>&nbsp;</P><PRE>a := b + c; Inc(Count); // INCORRECT
a := b + c;             // CORRECT
Inc(Count);             // CORRECT</PRE>
      <H5><A name=8.1.2></A>8.1.2 Local variable 
      declarations</H5>
      <P>Local variables should have Camel Caps, that 
      is, they should start with a capital letter, and have capital letters for 
      the beginning of each embedded word. Do not preface variable names with an 
      F, as that convention is reserved for Fields in a class 
      declaration:</P>
      <P>&nbsp;</P><PRE>var
  MyData: Integer;
  MyString: string;</PRE>
      <P>You may declare multiple identifiers of the 
      same type on a single line:</P>
      <P>&nbsp;</P><PRE>var
  ArraySize, ArrayCount: Integer;</PRE>
      <P>&nbsp;</P>
      <P>This practice is discouraged in class 
      declarations. There you should place each field on a separate line, along 
      with its type.</P>
      <P>You should only declare identifiers on a 
      single line if they are logically related.</P>
      <H5><A name=8.1.3></A>8.1.3 Array 
      declarations</H5>
      <P>There should always be a space before the 
      opening bracket "[" and after the closing bracket.</P>
      <P>&nbsp;</P><PRE>type
  TMyArray = array [0..100] of Char;</PRE>
      <H5><A name=8.2.3></A>8.2.3 if 
      statement</H5>
      <P>If statements should always appear on at 
      least two lines.</P>
      <P>&nbsp;</P>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>if A &lt; B then DoSomething;

if A &lt; B then
  DoSomething;</PRE>
      <PRE>&nbsp;</PRE>
      <P>In the JVCL the first example is allowed but 
      discouraged. Use it only in "obvious" situations such as "if 
      ParameterIncorrect then Exit;"</P>
      <P>In compound if statements, put each element 
      separating statements on a new line:</P>
      <P>&nbsp;</P>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>  // INCORRECT
  if A &lt; B then begin
    DoSomething;
    DoSomethingElse;
  end else begin
    DoThis;
    DoThat;
  end;

  // CORRECT
  if A &lt; B then
  begin
    DoSomething;
    DoSomethingElse;
  end
  else
  begin
    DoThis;
    DoThat;
  end;
  </PRE>
      <P>Here are a few more variations that are 
      considered valid (except for the second one, all these 
      variations are discouraged):</P>
      <P>&nbsp;</P><PRE>  // CORRECT
  if Condition then
  begin
    DoThis;
  end else
  begin
    DoThat;
  end;

  // CORRECT
  if Condition then
  begin
    DoThis;
  end
  else
    DoSomething;

  // CORRECT
  if Condition then
  begin
    DoThis;
  end else
    DoSomething;

  if Condition then
  begin
    DoThis;
  end
  else DoSomething;
  </PRE>
      <P>One that has fallen out of favor but deserves 
      honorable mention:</P>
      <P>&nbsp;</P><PRE>  if Condition then
    DoThis
  else DoThat;
  </PRE>
      <P>Avoid extraneous parentheses when formulating 
      the conditional in an if statement. In other words, don't encapsulate the 
      conditional statement in parenthesis if it's not syntactically required 
      and doesn't provide additional readability. An obvious example:</P>
      <P>&nbsp;</P><PRE>  // CORRECT
  if I &gt; 0 then 
    DoSomething;
    
  // INCORRECT
  if (I &gt; 0) then
    DoSomething;</PRE>
      <H5><A name=8.2.4></A>8.2.4 for 
      statement</H5>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>  // INCORRECT
  for i := 0 to 10 do begin
    DoSomething; 
    DoSomethingElse;
  end;

  // CORRECT
  for i := 0 to 10 do
  begin
    DoSomething;
    DoSomethingElse;
  end;</PRE>
      <P>&nbsp;</P>
      <P>If the body of the for loop consist of a 
      single statement then both of the examples below are allowed. As with if 
      statements, the first one is discouraged though.</P><PRE>&nbsp;</PRE>
      <PRE>  for I := 0 to 10 do DoSomething;

  for I := 0 to 10 do
    DoSomething;
  </PRE>
      <H5><A name=8.2.5></A>8.2.5 while 
      statement</H5>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>  // INCORRECT
  while x &lt; j  do begin
    DoSomething;
    DoSomethingElse;
  end;

  // CORRECT
  while x &lt; j do
  begin
    DoSomething;
    DoSomethingElse;
  end;
  </PRE>
      <P>The same as with for loops applies here. Both 
      of the following examples are allowed but the first one is 
      discouraged.</P>
      <P>&nbsp;</P><PRE>  while x &lt; j do Something;

  while x &lt; j do
    Something;</PRE>
      <H5><A name=8.2.6></A>8.2.6 repeat until 
      statement</H5>
      <P>Example:</P>
      <P>&nbsp;</P><PRE>  // CORRECT
  repeat
    x := j;
    j := UpdateValue;
  until j &gt; 25;</PRE>
      <H5><A name=8.2.7></A>8.2.7 case 
      statement</H5>
      <P>Example:</P><PRE>&nbsp;</PRE>
      <PRE>  // CORRECT
  case Control.Align of
    alLeft, alNone: NewRange := Max(NewRange, Position);
    alRight: Inc(AlignMargin, Control.Width);
  end;


  // CORRECT
  case ScrollCode of
    SB_LINEUP, SB_LINEDOWN:
      begin
        Incr := FIncrement div FLineDiv;
        FinalIncr := FIncrement mod FLineDiv;
        Count := FLineDiv;
      end;
    SB_PAGEUP, SB_PAGEDOWN:
      begin
        Incr := FPageIncrement;
        FinalIncr := Incr mod FPageDiv;
        Incr := Incr div FPageDiv;
        Count := FPageDiv;
      end;
  else
    Count := 0;
    Incr := 0;
    FinalIncr := 0;
  end;</PRE>
      <P>&nbsp;</P>
      <P>Except the obvious situations in which the 
      first variation is used for readability, the JVCL only uses the second 
      example. That is, each case label starts on a separate line with a two 
      column indent relative to the case statement and the body of that 
      particular case follows on the next line with an additional two column 
      indent. If the body on a particular case consists of only a single 
      statement then the begin...end pair can be omitted. In this case the 
      statement is aligned using a two column indent relative to the case 
      statement (identical to the begin reserved word in the example 
      above).</P>
      <H5><A name=8.2.8></A>8.2.8 try 
      statement</H5>
      <P>Example:</P><PRE>&nbsp;</PRE>
      <PRE>  // Correct
  try
    try
      EnumThreadWindows(CurrentThreadID, @Disable, 0);
      Result := TaskWindowList;
    except
      EnableTaskWindows(TaskWindowList);
      raise;
    end;
  finally
    TaskWindowList := SaveWindowList;
    TaskActiveWindow := SaveActiveWindow;
  end;</PRE>
      <H2><A name=9.0></A>9.0 Miscellanous</H2>
      <H5><A name=9.1></A>9.1 Const, Var and 
      Type</H5>
      <P>The reserved words var, const and type always 
      appear alone on a line. These example are correct:</P>
      <P>&nbsp;</P><PRE><B>type</B>
  TMyType = Integer;

<B>const</B>
  MyConstant = 100;

<B>var</B>
  MyVar: Integer;</PRE>
      <P>&nbsp;</P>
      <P>But these are not:</P><PRE>&nbsp;</PRE>
      <PRE><B>type</B> TMyType = Integer;

<B>const</B> MyConstant = 100;

<B>var</B> MyVar: Integer;</PRE>
      <P>&nbsp;</P>
      <P>Additionally a procedure should only have a 
      single type, const and var section and, if possible, in that order. For 
      example:</P><PRE>&nbsp;</PRE>
      <PRE><B>procedure</B> SomeProcedure;
<B>type</B>
  TMyType = Integer;
<B>const</B>
  ArraySize = 100;
<B>var</B>
  MyArray: <B>array</B> [1..ArraySize] <B>of</B> TMyType;
<B>begin</B>
  ...
<B>end</B>;</PRE>
      <H5><A name=9.2></A>9.2 Conditional 
      compilation</H5>
      <P>All JVCL units must include the JVCL.INC file. 
      This file defines a number of global directives. The include statement 
      should be placed between the unit and interface keywords. When using any 
      of the directives from this file, or others for that matter, you should 
      always repeat the conditional in the ENDIF directive. For 
      example:</P><PRE>{$IFDEF MSWINDOWS}
  // conditionally compiled code
{$ENDIF}</PRE>
      <P>This may seem overkill if the conditionally 
      compiled code only extends a few lines but is a tremendous visual aid when 
      the code actually spans multiple pages of code (as is often the case for 
      platform dependent code). Platform dependent code should use the 
      conditionals MSWINDOWS, for code intended to run on MS Windows platforms, 
      WIN32 for windows 32 only code, UNIX for unix compatible code and LINUX 
      for Linux only code.</P>
      <H5><A name=9.3></A>9.3 Resource 
      strings</H5>
      <P>All resourcestrings should be of the format 
      'Rs'[Category][Name]. [Category] should be (an abbreviation of) the 
      category in which the code resides, [Name] is a descriptive name for the 
      string itself. For example, the TJVCLCriticalSectionEx CreateEx constructor 
      raises an exception on initialization failure. The exception message is 
      declared as a resourcestring with the name 
      RsSynchInitCriticalSection.</P>
      <P>All resourcestrings must be declared in the 
      global JVCLResources.pas file which is included in each JVCL unit. This is 
      to ease translation. Literal strings should be avoided where possible (use 
      a constant whenever you can).</P>
      <H5><A name=9.4></A>9.4 Exceptions</H5>
      <P>Exceptions are prefixed with 'EJVCL' instead 
      of 'TJVCL'. All JVCL exceptions should be ultimately derived from EJVCLError 
      which is declared in JVCLBase.</P>
      <P>When raising an exception you should prefer 
      the CreateRes(ResStringRec: PResStringRec) constructor for efficiency. 
      Thus, an exception is raised like this:</P><PRE><B>raise</B> EJVCLSomeException.CreateRes(@RsSomeResourceString);</PRE>
      <H5><A name=9.5></A>9.5 Categories and routine 
      separation</H5>
      <P>Typically each JVCL unit is a single category. 
      For example, JvSynch contains all kinds of synchronization classes and 
      subroutines. Within a unit there is usually a further categorization, for 
      example JvSynch has a number of 'Locked Integer Manipulation' routines 
      which form a subcategory within this unit. In the interface section each 
      subcategory is divided using two 100 column width lines in between which 
      there is a one line description of the subcategory. For 
example:</P><PRE>&nbsp;</PRE>
      <PRE><B>function</B> LockedAdd(<B>var</B> Target: Integer; Value: Integer): Integer;
<B>function</B> LockedCompareExchange(<B>var</B> Target: Integer; Exch, Comp: Integer): Integer;</PRE>
      <P>&nbsp;</P>
      <P>In the implementation section this separation 
      is identical except that the lines are composed using the equals character 
      (=).</P><PRE>&nbsp;</PRE>
      <PRE><B>function</B> LockedAdd(<B>var</B> Target: Integer; Value: Integer): Integer;
<B>asm</B>
  MOV     ECX, EAX</PRE>
      <P>&nbsp;</P>
      <P>In the implementation section each routine or 
      method is separated from its predecessor using a 80 column width line 
      composed of minus characters (-).</P><PRE>&nbsp;</PRE>
      <PRE>  <B>if</B> (L &gt; 0) <B>and</B> (Path[L] &lt;&gt; PathSeparator) <B>then</B> Result := Path + PathSeparator;
<B>end</B>;


<B>function</B> PathAddExtension(<B>const</B> Path, Extension: <B>string</B>): <B>string</B>;
<B>begin</B>
  Result := Path;
  <B>if</B> (Path &lt;&gt; '') <B>and</B> (ExtractFileExt(Path) = '') <B>and</B> (Extension &lt;&gt; '') <B>then</B>
  <B>begin</B>
    <B>if</B> Extension[1] = '.' <B>then</B>
      Result := Result + Extension
    <B>else</B>
      Result := Result + '.' + Extension;
  <B>end</B>;
<B>end</B>;


<B>function</B> PathAppend(<B>const</B> Path, Append: <B>string</B>): <B>string</B>;
<B>var</B>
  PathLength: Integer;
  B1, B2: Boolean;
<B>begin</B>
  <B>if</B> Append = '' <B>then</B>
    Result := Path</PRE>
      <H5><A name=9.6></A>9.6 Assembler</H5>
      <P>Assembler is formatted like this:</P>
      <P>&nbsp;</P><PRE>        REP     MOVSW
        JMP     @@2
@@1:
        LEA     ESI, [ESI + 2 * ECX - 2]
        LEA     EDI, [EDI + 2 * ECX - 2]</PRE>
      <P>&nbsp;</P>
      <P>That is, the opcode is indented 8 spaces and 
      the operands are aligned on the 16th column. Labels should be indented 
      with two spaces or aligned on the left side and be camel case. All opcodes 
      and registers should be written fully in uppercase. Numeric labels are 
      acceptable but a more descriptive name is preferred. General punctuation 
      formatting still applies, e.g. a single space after each comma and a space 
      on both sides of an operator (such as the addition operator +). 
      Additionally, never put labels and commands on the same line and always 
      prefix labels with the @ character to make the label scope local. 
      Generically speaking, assembler should be avoided but if it is used it 
      should be heavily commented.</P>
      <H5><A name=9.7></A>9.7 Local 
      routines</H5>
      <P>Local functions should be indented two spaces 
      in their entirety and separated from the procedure declaration and begin 
      statement by a single line. If the 'outer' procedure (SomeProcedure in the 
      example) has local variables these should be declared before the local 
      procedure, regardless of whether the local procedure needs access to them. 
      However, local routines should be avoided. Whenever it seems reasonable to 
      extract code as a local subroutine, think carefully whether the routine 
      can be made more generic and extracted as a normal, global routine (of 
      course should be moved to the appropriate unit as well). For 
      example:</P><PRE>&nbsp;</PRE>
      <PRE><B>procedure</B> SomeProcedure;
<B>var</B>
  I: Integer;

  <B>procedure</B> LocalProcedure;
  <B>begin</B>
    ...
  <B>end</B>;

<B>begin</B>
  ...
  LocalProcedure;
  ...
<B>end</B>;</PRE>
      <H5><A name=9.8></A>9.8 Parameter
      declarations</H5>
      <P>When declaring the parameters list of a
      procedure, function or method, observe the following
      recommendations:</P>
      <P>&nbsp;</P>
      <UL>
        <LI>
        <P>Combine formal
        parameters of same type into one statement</P>
        <LI>
        <P>Usage of A in parameter names is
        discouraged unless it concerns a method of a class which has as a
        property which is named identical.</P></LI></UL>
        <P>&nbsp;</P>
        <P>&nbsp;</P>
      <P>Although technically these are not formatting
      issues, I'd like to methion them here anyway:</P>
      <P>&nbsp;</P>
      <UL>
        <LI>
        <P>Ordering of parameters should be: input,
        input./output and output parameters and within that ordering: most used,
        least used. Parameters with default values are, as required by the
        Object Pascal language rules, always placed at
         the back of the list.</P>
        <LI>
        <P>Use of const for parameter types is
        recommended even if it's use does not increases the efficiency of the
        parameter passing. For example, a parameter of type Integer should be
        declared with the const modifier if that's the semantic meaning of the
        parameter in question.</P></LI></UL>
      <H5><A name=9.9></A>9.9 Initialization of global
      variables</H5>
      <P>Global variables are, like class members,
      automatically initialized to 0. This has different meaning for different
      types. For example, and Integer is initialized to 0 while a pointer is
      initialized to nil. Because of this, if the global variable needs to be 0
      initialized, which is often the case, this should not be done explicitly.
      Instead you should rely on Delphi to do this for you. This is for
      efficiency reasons btw because it influences how the variable ends up in
      the executable and later in memory. If you desire you can add a comment to
      indicate reliance on 0 initialization like so:</P>
      <P>&nbsp;</P><PRE>var
  MyGlobalVariable: Pointer{ = nil};</PRE></BODY></HTML>
