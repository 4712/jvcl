{******************************************************************************}
{* WARNING:  JEDI VCL To CLX Converter generated unit.                        *}
{*           Manual modifications will be lost on next release.               *}
{******************************************************************************}

{-----------------------------------------------------------------------------
The contents of this file are subject to the Mozilla Public License
Version 1.1 (the "License"); you may not use this file except in compliance
with the License. You may obtain a copy of the License at
http://www.mozilla.org/MPL/MPL-1.1.html

Software distributed under the License is distributed on an "AS IS" basis,
WITHOUT WARRANTY OF ANY KIND, either expressed or implied. See the License for
the specific language governing rights and limitations under the License.

The Original Code is: JvExControls.pas, released on 2004-01-04

The Initial Developer of the Original Code is Andreas Hausladen [Andreas dott Hausladen att gmx dott de]
Portions created by Andreas Hausladen are Copyright (C) 2004 Andreas Hausladen.
All Rights Reserved.

Contributor(s): -

You may retrieve the latest version of this file at the Project JEDI's JVCL home page,
located at http://jvcl.sourceforge.net

Known Issues:
-----------------------------------------------------------------------------}
// $Id$

unit JvQExControls;

{$I jvcl.inc}

{*****************************************************************************
 * WARNING: Do not edit this file.
 * This file is autogenerated from the source in devtools/JvExVCL/src.
 * If you do it despite this warning your changes will be discarded by the next
 * update of this file. Do your changes in the template files.
 ****************************************************************************}

interface

uses
  {$IFDEF MSWINDOWS}
  Windows,
  {$ENDIF MSWINDOWS}
  {$IFDEF HAS_UNIT_LIBC}
  Libc,
  {$ENDIF HAS_UNIT_LIBC}
  QMessages, QGraphics, QControls, QForms,
  Qt, QTypes, QStdCtrls, QMask, QClipbrd, QWindows, QExtCtrls,
  Classes, SysUtils,
  JvQTypes, JvQThemes, JVCLXVer;

type
  TDlgCode = (
    dcWantAllKeys, dcWantArrows, dcWantTab, dcWantChars,
    dcButton,
    dcNative // if dcNative is in the set the native functions are used and DoGetDlgCode is ignored
  );
  TDlgCodes = set of TDlgCode;


  TAlignInfo = record
    AlignList: TList;
    ControlIndex: Integer;
    Align: TAlign;
    Scratch: Integer;
  end;

  TBevelKind = (bkNone, bkTile, bkSoft, bkFlat);

  TCaption = QTypes.TCaption;
  HWND = QWindows.HWND;
  TClxWindowProc = procedure(var Msg: TMessage) of object;
  TCMFocusChanged = QMessages.TCMFocusChanged ;
  {$NODEFINE TCMFocusChanged}
  
const
  QEventType_FontChanged = QEventType(Integer(QEventType_User) + $70);
  CM_FOCUSCHANGED = QMessages.CM_FOCUSCHANGED;

const
  dcWantMessage = dcWantAllKeys;

type

  IJvControlEvents = interface(IPerformControl)
    ['{61FC57FF-D4DA-4840-B871-63DE804E9921}']
    procedure VisibleChanged;
    procedure EnabledChanged;
    procedure TextChanged;
    procedure FontChanged;
    procedure ColorChanged;
    procedure ParentFontChanged;
    procedure ParentColorChanged;
    procedure ParentShowHintChanged;
    function WantKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; // CM_DIALOGCHAR
    function HintShow(var HintInfo: THintInfo): Boolean;
    function HitTest(X, Y: Integer): Boolean; // CM_HITTEST
    procedure MouseEnter(AControl: TControl);
    procedure MouseLeave(AControl: TControl);
    procedure DoFocusChanged(Control: TWinControl);
  end;

  IJvWinControlEvents = interface(IJvControlEvents)
    ['{B5F7FB62-78F0-481D-AFF4-7A24ED6776A0}']
    procedure DoBoundsChanged;
    procedure CursorChanged;
    procedure ShowingChanged;
    procedure ShowHintChanged;
    procedure ControlsListChanging(Control: TControl; Inserting: Boolean);
    procedure ControlsListChanged(Control: TControl; Inserting: Boolean);
    procedure DoGetDlgCode(var Code: TDlgCodes); // WM_GETDLGCODE
    procedure DoSetFocus(FocusedWnd: HWND);  // WM_SETFOCUS
    procedure DoKillFocus(FocusedWnd: HWND); // WM_KILLFOCUS
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; // WM_ERASEBKGND
    procedure DoFontChanged(Sender: TObject);  // CM_FONTCHANGED
    procedure Paint;
  end;

  IJvCustomControlEvents = interface(IJvWinControlEvents)
    ['{7804BD3A-D7A5-4314-9259-6DE08A0DC38A}']
    // implements doublebuffering for  TCustomControl derived classes and
    // TJvExWidgetControl.
    function GetDoubleBuffered: Boolean;
  end;

  IJvEditControlEvents = interface(IPerformControl)
    ['{C1AE5EF8-F6C4-4BD4-879E-17946FD0FBAB}']
    procedure DoClipboardPaste;
    procedure DoClipboardCopy;
    procedure DoClipboardCut;
    procedure DoUndo;
    procedure DoClearText;
  end;

  IEditControlEvents = interface
    procedure PasteFromClipboard;
    procedure CopyToClipboardCopy;
    procedure CutToClipboard;
    procedure Undo;
    procedure Clear;
  end;

const
  CM_DENYSUBCLASSING = JvQThemes.CM_DENYSUBCLASSING;

type
  { Add IJvDenySubClassing to the base class list if the control should not
    be themed by the ThemeManager (www.delphi-gems.de).
    This only works with JvExVCL derived classes. }
  IJvDenySubClassing = interface
    ['{76942BC0-2A6E-4DC4-BFC9-8E110DB7F601}']
  end;

  TJvExControl = class(TControl, IJvControlEvents, IPerformControl)
  // IJvControlEvents
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override; 
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False; 
  
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TJvExPubControl = class(TJvExControl)
  end;

  TJvExWinControl = class(TWinControl, IJvWinControlEvents, IJvCustomControlEvents, IJvControlEvents, IPerformControl)
  private
    FBevelEdges: TBevelEdges;
    FBevelInner: TBevelCut;
    FBevelOuter: TBevelCut;
    FBevelKind: TBevelKind;
    FBevelWidth: TBevelWidth;
    FBorderWidth: TBorderWidth;
    procedure SetBevelCut(Index: Integer; Value: TBevelCut);
    procedure SetBevelEdges(Value: TBevelEdges);
    procedure SetBevelKind(Value: TBevelKind);
    procedure SetBevelWidth(Value: TBevelWidth);
    procedure SetBorderWidth(Value: TBorderWidth);
  protected
    procedure AdjustClientRect(var Rect: TRect); override;
    procedure BorderStyleChanged; dynamic;
    property BevelEdges: TBevelEdges read FBevelEdges write SetBevelEdges default [beLeft, beTop, beRight, beBottom];
    property BevelInner: TBevelCut index 0 read FBevelInner write SetBevelCut default bvRaised;
    property BevelOuter: TBevelCut index 1 read FBevelOuter write SetBevelCut default bvLowered;
    property BevelKind: TBevelKind read FBevelKind write SetBevelKind default bkNone;
    property BevelWidth: TBevelWidth read FBevelWidth write SetBevelWidth default 1;
    property BorderWidth: TBorderWidth read FBorderWidth write SetBorderWidth default 0;
  public
    function ColorToRGB(AColor: TColor): TColor;
  // IJvControlEvents
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  private
//    InternalFontChanged: TNotifyEvent;
    FFontHeight: integer;
    procedure OnFontChanged(Sender: TObject);
  protected
    procedure BoundsChanged; override;
    procedure DoFontChanged(Sender: TObject); dynamic;
    function EventFilter(Sender: QObjectH; Event: QEventH): Boolean; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure PaintWindow(PaintDevice: QPaintDeviceH);
    function WidgetFlags: integer; override;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;
    procedure RecreateWnd;
  public
    procedure PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private  
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False; 
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual;
  private
    FDoubleBuffered: Boolean;
    function GetDoubleBuffered: Boolean;
    procedure SetDoubleBuffered(Value: Boolean);
  protected
    procedure ColorChanged; override;
  published // asn: change to public in final
    property DoubleBuffered: Boolean read GetDoubleBuffered write SetDoubleBuffered;
 
  private
    FCanvas: TCanvas;
  protected
    procedure Paint; virtual;
    property Canvas: TCanvas read FCanvas; 
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TJvExPubWinControl = class(TJvExWinControl)
  published
    Property Bitmap;
    property InputKeys;
  end;
   
  TJvExGraphicControl = class(TGraphicControl, IJvControlEvents, IPerformControl)  
  // IJvControlEvents
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override; 
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private  
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False; 
  
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override; 
  private
    FText: TCaption; // TControl does not save the Caption property
  protected
    function GetText: TCaption; override;
    procedure SetText(const Value: TCaption); override;
    procedure PaintRequest; override;
  end;

  TJvExPubGraphicControl = class(TJvExGraphicControl) 
  end;
  

  {$UNDEF CONSTRUCTORCODE}
  {$DEFINE CONSTRUCTORCODE DoubleBuffered := True;}
  TJvExCustomControl = class(TCustomControl,  IJvWinControlEvents, IJvCustomControlEvents, IJvControlEvents, IPerformControl)  
  // IJvControlEvents
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  private
//    InternalFontChanged: TNotifyEvent;
    FFontHeight: integer;
    procedure OnFontChanged(Sender: TObject);
  protected
    procedure BoundsChanged; override;
    procedure DoFontChanged(Sender: TObject); dynamic;
    function EventFilter(Sender: QObjectH; Event: QEventH): Boolean; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure PaintWindow(PaintDevice: QPaintDeviceH);
    function WidgetFlags: integer; override;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;
    procedure RecreateWnd;
  public
    procedure PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private  
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False; 
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual; 
  private
    FDoubleBuffered: Boolean;
    function GetDoubleBuffered: Boolean;
    procedure SetDoubleBuffered(Value: Boolean);
  protected
    procedure ColorChanged; override;
  published // asn: change to public in final
    property DoubleBuffered: Boolean read GetDoubleBuffered write SetDoubleBuffered;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TJvExPubCustomControl = class(TJvExCustomControl)
  published
    Property Bitmap;
    Property InputKeys;
  end;
  
  {$UNDEF CONSTRUCTORCODE}
  {$DEFINE CONSTRUCTORCODE}

  TJvExHintWindow = class(THintWindow,  IJvWinControlEvents, IJvCustomControlEvents, IJvControlEvents, IPerformControl)
  // IJvControlEvents
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  private
//    InternalFontChanged: TNotifyEvent;
    FFontHeight: integer;
    procedure OnFontChanged(Sender: TObject);
  protected
    procedure BoundsChanged; override;
    procedure DoFontChanged(Sender: TObject); dynamic;
    function EventFilter(Sender: QObjectH; Event: QEventH): Boolean; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure PaintWindow(PaintDevice: QPaintDeviceH);
    function WidgetFlags: integer; override;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;
    procedure RecreateWnd;
  public
    procedure PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer); 
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False; 
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual; 
  private
    FDoubleBuffered: Boolean;
    function GetDoubleBuffered: Boolean;
    procedure SetDoubleBuffered(Value: Boolean);
  protected
    procedure ColorChanged; override;
  published // asn: change to public in final
    property DoubleBuffered: Boolean read GetDoubleBuffered write SetDoubleBuffered;

  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TJvExPubHintWindow = class(TJvExHintWindow)
  end;

  TJvExFrameControl = class(TFrameControl, IJvWinControlEvents, IJvControlEvents, IPerformControl)
  // IJvControlEvents
  public
    function Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
    function IsRightToLeft: Boolean;
  protected
    WindowProc: TClxWindowProc;
    procedure WndProc(var Msg: TMessage); virtual;
    procedure MouseEnter(Control: TControl); override;
    procedure MouseLeave(Control: TControl); override;
    procedure ParentColorChanged; override;
  private
//    InternalFontChanged: TNotifyEvent;
    FFontHeight: integer;
    procedure OnFontChanged(Sender: TObject);
  protected
    procedure BoundsChanged; override;
    procedure DoFontChanged(Sender: TObject); dynamic;
    function EventFilter(Sender: QObjectH; Event: QEventH): Boolean; override;
    function NeedKey(Key: Integer; Shift: TShiftState;
      const KeyText: WideString): Boolean; override;
    procedure Painting(Sender: QObjectH; EventRegion: QRegionH); override;
    procedure PaintWindow(PaintDevice: QPaintDeviceH);
    function WidgetFlags: integer; override;
    procedure CreateWnd; dynamic;
    procedure CreateWidget; override;
    procedure RecreateWnd;
  public
    procedure PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
  private
    FHintColor: TColor;
    FSavedHintColor: TColor;
    FMouseOver: Boolean;
    FOnParentColorChanged: TNotifyEvent;
  protected
    procedure CMFocusChanged(var Msg: TCMFocusChanged); message CM_FOCUSCHANGED;
    procedure DoFocusChanged(Control: TWinControl); dynamic;
    property MouseOver: Boolean read FMouseOver write FMouseOver;
    property HintColor: TColor read FHintColor write FHintColor default clInfoBk;
    property OnParentColorChange: TNotifyEvent read FOnParentColorChanged write FOnParentColorChanged;
  private
    FAboutJVCLX: TJVCLAboutInfo;
  published
    property AboutJVCLX: TJVCLAboutInfo read FAboutJVCLX write FAboutJVCLX stored False;
  protected
    procedure DoGetDlgCode(var Code: TDlgCodes); virtual;
    procedure DoSetFocus(FocusedWnd: HWND); dynamic;
    procedure DoKillFocus(FocusedWnd: HWND); dynamic;
    procedure DoBoundsChanged; dynamic;
    function DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean; virtual;
  private
    FCanvas: TCanvas;
  protected
    procedure Paint; virtual;
    property Canvas: TCanvas read FCanvas;
  public
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;
  end;

  TJvExPubFrameControl = class(TJvExFrameControl)
  published
    Property Bitmap;
    Property InputKeys;
end;

function ColorToRGB(Color: TColor; Instance: TWidgetControl = nil): TColor;

procedure Control_MouseEnter(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; FHintColor: TColor);

procedure Control_MouseLeave(Instance, Control: TControl; var FMouseOver: Boolean; FSavedHintColor: TColor);

function DefaultDoPaintBackground(Instance: TWinControl; Canvas: TCanvas; Param: Integer): Boolean;

// handles fontchanged & focuschanged
function WidgetControl_EventFilter(Instance: TWidgetControl; Sender: QObjectH; Event: QEventH): Boolean;

// Paint method for native Qt Controls
procedure WidgetControl_DefaultPaint(Instance: TWidgetControl; Canvas: TCanvas);
procedure WidgetControl_Painting(Instance: TWidgetControl; Canvas: TCanvas;
  EventRegion: QRegionH);

// - redirects Canvas.Handle to a Pixmap if Instance.DoubleBuffered is set
// - calls Instance.Paint
procedure CustomControl_Painting(Instance: TWidgetControl; Canvas: TCanvas;
  EventRegion: QRegionH);
procedure WidgetControl_ColorChanged(Instance: TWidgetControl);

// support for PaintTo & PaintWindow
procedure WidgetControl_PaintTo(Instance: TWidgetControl; PaintDevice: QPaintDeviceH; X, Y: integer);
procedure Control_PaintTo(Instance: TControl; PaintDevice: QPaintDeviceH; X, Y: integer);

function WidgetControl_NeedKey(Instance: TWidgetControl; Key: Integer;
  Shift: TShiftState; const KeyText: WideString; InheritedValue: Boolean): Boolean;

procedure TCustomEdit_Undo(Instance: TWinControl);
procedure TCustomEdit_Copy(Instance: TWinControl);
procedure TCustomEdit_Paste(Instance: TWinControl);
procedure TCustomEdit_Cut(Instance: TWinControl);

implementation

type
  THackedControl = class(TControl);

  THackedWidgetControl = class(TWidgetControl);
  THackedCustomControl = class(TCustomControl);
  THackedCustomEdit = class(TCustomEdit);
  THackedCustomMaskEdit = class(TCustomMaskEdit);

function ColorToRGB(Color: TColor; Instance: TWidgetControl = nil): TColor;
begin
  Result := QWindows.ColorToRGB(Color, Instance);
end;

procedure Control_MouseEnter(Instance, Control: TControl; var FMouseOver: Boolean;
  var FSavedHintColor: TColor; FHintColor: TColor);

begin
  // (HEG) VCL: Control is nil iff Instance is the control that the mouse has left.
  // Otherwise this is just a notification that the mouse entered
  // one of its child controls
  if  not FMouseOver and not (csDesigning in Instance.ComponentState) then
  begin
    FMouseOver := True;
    FSavedHintColor := Application.HintColor;
    if FHintColor <> clNone then
      Application.HintColor := FHintColor;
  end;
end;

procedure Control_MouseLeave(Instance, Control: TControl; var FMouseOver: Boolean; FSavedHintColor: TColor);
begin
  // (HEG) Control is nil iff Instance is the control that the mouse has left.
  // Otherwise this is just a notification that the mouse left
  // one of its child controls
  if  FMouseOver and not (csDesigning in Instance.ComponentState) then
  begin
    FMouseOver := False;
    Application.HintColor := FSavedHintColor;
  end;
end;

function DefaultDoPaintBackground(Instance: TWinControl; Canvas: TCanvas; Param: Integer): Boolean;
begin
  Result := false; //QWidget_BackgroundMode(Instance.Handle) = QWidgetBackgroundMode_NoBackground;
end;

procedure WidgetControl_PaintTo(Instance: TWidgetControl; PaintDevice: QPaintDeviceH; X, Y: integer);
var
  PixMap: QPixmapH;
begin
  PixMap := QPixmap_create;
  with Instance do
    try
      ControlState := ControlState + [csPaintCopy];
      QPixmap_grabWidget(PixMap, Handle, 0, 0, Width, Height);
      Qt.BitBlt(PaintDevice, X, Y, PixMap, 0, 0, Width, Height, RasterOp_CopyROP, True);
    finally
      ControlState := ControlState - [csPaintCopy];
      QPixMap_destroy(PixMap);
    end;
end;

procedure Control_PaintTo(Instance: TControl; PaintDevice: QPaintDeviceH;
  X, Y: integer);
var
  PixMap: QPixmapH;
begin
  if Instance is TWidgetControl then
    WidgetControl_PaintTo(TWidgetControl(Instance), PaintDevice, X, Y)
  else
  if Assigned(Instance.Parent) then
  begin
    PixMap := QPixmap_create;
    try
      with Instance do
      begin
        Parent.ControlState := Parent.ControlState + [csPaintCopy];
        try
          QPixmap_grabWidget(PixMap, Parent.Handle, Left, Top, Width, Height);
          Qt.BitBlt(PaintDevice, X, Y, PixMap, 0, 0, Width, Height, RasterOp_CopyROP, True);
        finally
          Parent.ControlState := Parent.ControlState - [csPaintCopy];
        end;
      end;
    finally
      QPixMap_destroy(PixMap);
    end;
  end;
end;

function WidgetControl_EventFilter(Instance: TWidgetControl; Sender: QObjectH; Event: QEventH): Boolean;
var
  Intf: IJvWinControlEvents;
  Wnd: QWidgetH;
begin
  Result := false;
  try
    case QEvent_type(Event) of
      QEventType_FocusIn, QEventType_FocusOut:
        begin
          if Supports(Instance, IJvWinControlEvents, Intf) then
          begin
            if Screen.ActiveControl <> nil then
              Wnd := Screen.ActiveControl.Handle
            else
              Wnd := nil;
            if QEvent_type(Event) = QEventType_FocusIn then
              Intf.DoSetFocus(Wnd)
            else
              Intf.DoKillFocus(Wnd);
          end;
        end;
      QEventType_FontChanged:
        begin
          if Supports(Instance, IJvWinControlEvents, Intf) then
          begin
            Intf.DoFontChanged(Instance);
            Result := true;
          end;
        end;
    end;
  except
    on E: Exception do
    begin
      Application.ShowException(E);
      Result := False;
    end;
  end;
end;

procedure CustomControl_Painting(Instance: TWidgetControl; Canvas: TCanvas;
  EventRegion: QRegionH);
var
  HasBackground: Boolean;
  Pixmap: QPixmapH;
  OriginalPainter: QPainterH;
  Intf: IJvCustomControlEvents;
  IsDoubleBuffered: Boolean;
  R: TRect;
begin
  if (csDestroying in Instance.ComponentState) or not Assigned(Instance.Parent) then
    Exit;

  R := Rect(0, 0, 0, 0);
  QRegion_boundingRect(EventRegion, @R);
  if IsRectEmpty(R) then
    Exit;

  Instance.GetInterface(IJvCustomControlEvents, Intf);
  IsDoubleBuffered := Intf.GetDoubleBuffered;
  Pixmap := nil;
  OriginalPainter := nil;

  with THackedWidgetControl(Instance) do
  begin
    TControlCanvas(Canvas).StartPaint;
    if IsDoubleBuffered then
    begin
      Pixmap := QPixmap_create(Instance.Width, Instance.Height, -1, QPixmapOptimization_DefaultOptim);
      // fill with parent's background if the control has a parent
      if Instance.Parent <> nil then
        QPixmap_fill(Pixmap, Instance.Parent.Handle, QWidget_x(Instance.Handle), QWidget_y(Instance.Handle));
      OriginalPainter := Canvas.Handle;
      Canvas.Handle := QPainter_create(Pixmap);
      TControlCanvas(Canvas).StartPaint;
      QPainter_setClipRegion(Canvas.Handle, EventRegion);
      QPainter_setClipping(Canvas.Handle, True);
    end;
    try
      Canvas.Brush.Assign(Brush);
      Canvas.Font.Assign(Font);
      QPainter_setFont(Canvas.Handle, Canvas.Font.Handle);
      QPainter_setPen(Canvas.Handle, Canvas.Font.FontPen);
      QPainter_setBrush(Canvas.Handle, Canvas.Brush.Handle);

      HasBackground := (Instance as IJvWinControlEvents).DoPaintBackground(Canvas, 0);

      if IsDoubleBuffered then
      begin
        if not HasBackground then
        begin
          // fill with control's background
          if (QWidget_backgroundPixmap(Handle) <> nil) and
             not QPixmap_isNull(QWidget_backgroundPixmap(Handle)) then
            QPixmap_fill(Pixmap, Handle, 0, 0)
          else
          begin
            Canvas.FillRect(Rect( 0, 0, Width, Height));
          end;
        end;
      end;
      if Instance is TCustomForm then
        // TCustomForm calls Paint in it's EventFilter
      else
      if Instance is TCustomControl then
        THackedCustomControl(Instance).Paint
      else
        (Instance as IJvWinControlEvents).Paint;
    finally
      if Pixmap <> nil then
      begin
        TControlCanvas(Canvas).StopPaint;
        QPainter_destroy(Canvas.Handle);
        Canvas.Handle := OriginalPainter;
        bitBlt(QPainter_device(Canvas.Handle), R.Left, R.Top,
          Pixmap, R.Left, R.Top, R.Right - R.Left, R.Bottom - R.Top,
          RasterOp_CopyROP, True);
        QPixmap_destroy(Pixmap);
      end;
      TControlCanvas(Canvas).StopPaint;
    end;
  end;
end;

procedure WidgetControl_Painting(Instance: TWidgetControl; Canvas: TCanvas;
  EventRegion: QRegionH);
var
  R: TRect;
begin
  if (csDestroying in Instance.ComponentState) or
    not Assigned(Instance.Parent) then
    Exit;

  R := Rect(0, 0, 0, 0);
  QRegion_boundingRect(EventRegion, @R);
  if IsRectEmpty(R) then
    exit;
  with THackedWidgetControl(Instance) do
  begin
    TControlCanvas(Canvas).StartPaint;
    try
      Canvas.Brush.Assign(Brush);
      Canvas.Font.Assign(Font);
      QPainter_setFont(Canvas.Handle, Canvas.Font.Handle);
      QPainter_setPen(Canvas.Handle, Canvas.Font.FontPen);
      QPainter_setBrush(Canvas.Handle, Canvas.Brush.Handle);

      if Instance is TCustomForm then
        // TCustomForm calls Paint in it's EventFilter
      else
        (Instance as IJvWinControlEvents).Paint;
    finally
      TControlCanvas(Canvas).StopPaint;
    end;
  end;
end;

type
  THackedExWinControl = class(TJvExWinControl);

procedure WinControl_Paint(Instance: TWidgetControl; Canvas: TCanvas);
const
  InnerStyles: array[TBevelCut] of Integer = (0, BDR_SUNKENINNER, BDR_RAISEDINNER);
  OuterStyles: array[TBevelCut] of Integer = (0, BDR_SUNKENOUTER, BDR_RAISEDOUTER);
  EdgeStyles: array[TBevelKind] of Integer = (0, 0, BF_SOFT, BF_FLAT);
var
  FEdgeSize: Integer;
  R: TRect;
begin
  WidgetControl_DefaultPaint(Instance, Canvas);
  with Canvas, THackedExWinControl(Instance) do
  begin
    if BevelKind = bkNone then Exit;
    R := Bounds(0, 0, Width, Height);
    Canvas.Brush.Color := Color;
    QWindows.FrameRect(Canvas, R);
    InflateRect(R,-1,-1);
    QWindows.FrameRect(Canvas, R);
    if BevelKind <> bkNone then
    begin
      FEdgeSize := 0;
      if BevelInner <> bvNone then Inc(FEdgeSize, BevelWidth);
      if BevelOuter <> bvNone then Inc(FEdgeSize, BevelWidth);
      if FEdgeSize = 0 then
      begin
        R := ClientRect;
        Canvas.Brush.Color := Color;
        QWindows.FrameRect(Canvas, R);
        InflateRect(R, -1, -1);
        QWindows.FrameRect(Canvas, R);
      end;
      R := Bounds(0, 0, Width, Height);
      with R do
      begin
        if beLeft in BevelEdges then Dec(Left, FEdgeSize);
        if beTop in BevelEdges then Dec(Top, FEdgeSize);
        if beRight in BevelEdges then Inc(Right, FEdgeSize);
        if beBottom in BevelEdges then Inc(Bottom, FEdgeSize);
      end;
      DrawEdge(Canvas.Handle, R, InnerStyles[BevelInner] or OuterStyles[BevelOuter],
        Byte(BevelEdges) or EdgeStyles[BevelKind]);
    end;
  end;
end;

procedure WidgetControl_DefaultPaint(Instance: TWidgetControl; Canvas: TCanvas);
var
  PaintDevice: QPaintDeviceH;
  IsActive: Boolean;
  Painting: procedure(Instance: TWidgetControl; Sender: QObjectH; EventRegion: QRegionH);
  Painter: QPainterH;
begin
  if not (csDestroying in Instance.ComponentState) and
     (not Supports(Instance, IJvCustomControlEvents)) then
       { TCustomControls do not have a Qt paint method. }
  begin
   // Canvas.StopPaint uses a counter, but we must garantee the Stop.
    PaintDevice := nil;
    Painter := Canvas.Handle;
    IsActive := QPainter_isActive(Painter);
    if IsActive then
    begin
      PaintDevice := QPainter_device(Painter);
      QPainter_end(Painter);
    end;
    try
      Painting := @THackedWidgetControl.Painting;
     // default painting
      Painting(Instance, Instance.Handle, QPainter_clipRegion(Painter));
    finally
      // restore
      if IsActive then
        QPainter_begin(Painter, PaintDevice); // restart
    end;
  end;
end;

function WidgetControl_NeedKey(Instance: TWidgetControl; Key: Integer;
  Shift: TShiftState; const KeyText: WideString; InheritedValue: Boolean): Boolean;

  function IsTabKey: Boolean;
  begin
    Result := (Key = Key_Tab) or (Key = Key_BackTab);
  end;

  function IsArrowKey: Boolean;
  begin
    Result := (Key = Key_Left) or (Key = Key_Right) or (Key = Key_Down) or (Key = Key_Up);
  end;

var
  DlgCodes: TDlgCodes;
  Value: TInputKeys;
begin
  Result := InheritedValue;
  Value := THackedWidgetControl(Instance).InputKeys;

  DlgCodes := [dcNative];
  if ikAll in Value then
    Include(DlgCodes, dcWantAllKeys);
  if ikArrows in Value then
    Include(DlgCodes, dcWantArrows);
  if ikTabs in Value then
    Include(DlgCodes, dcWantTab);
  if ikChars in Value then
    Include(DlgCodes, dcWantChars);

  (Instance as IJvWinControlEvents).DoGetDlgCode(DlgCodes);

  if not (dcNative in DlgCodes) then
  begin
    Result := False;
    if dcWantAllKeys in DlgCodes then
      Result := True;
    if (not Result) and (dcWantTab in DlgCodes) then
      Result := IsTabKey;
    if (not Result) and (dcWantArrows in DlgCodes) then
      Result := IsArrowKey;
    if (not Result) and (dcWantChars in DlgCodes) then
      Result := ((Shift * [ssCtrl, ssAlt] = []) and
        ((Hi(Word(Key)) = 0) or (Length(KeyText) > 0))) and
        not (IsTabKey or IsArrowKey);
  end;
end;

procedure WidgetControl_ColorChanged(Instance: TWidgetControl);
var
  TC: QColorH;
  Intf: IJvCustomControlEvents;
begin
  with THackedWidgetControl(Instance) do
  begin
    HandleNeeded;
    Instance.GetInterface(IJvCustomControlEvents, Intf);
    if Bitmap.Empty then
    begin
      Palette.Color := Brush.Color;
      if not Intf.GetDoubleBuffered then
      begin
        TC := QColor(Color);
        QWidget_setBackgroundColor(Handle, TC);
        QColor_destroy(TC);
      end;
    end;
    NotifyControls(CM_PARENTCOLORCHANGED);
    Invalidate;
  end;
end;

procedure QClxLineEdit_undo(handle: QLineEditH);
var
  W: WideString;
  Event: QKeyEventH;
begin
  W := 'Z';
  Event := QKeyEvent_create(QEventType_KeyPress, KEY_Z, Ord('Z'),
    Integer(ButtonState_ControlButton), @W, False, 1);
  try
    QApplication_sendEvent(handle, Event);
  finally
    QKeyEvent_destroy(Event);
  end;
end;

procedure TCustomEdit_Undo(Instance: TWinControl);
begin
  if Instance is TCustomMemo then
    QMultiLineEdit_undo(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomEdit then
    QClxLineEdit_undo(QClxLineEditH(Instance.Handle));
end;

procedure TCustomEdit_Copy(Instance: TWinControl);
begin
  if Instance is TCustomMemo then
    QMultiLineEdit_copy(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomEdit then
    QClxLineEdit_copy(QClxLineEditH(Instance.Handle));
end;

procedure TCustomEdit_Cut(Instance: TWinControl);
begin  
  if Instance is TCustomMemo then
    QMultiLineEdit_cut(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomMaskEdit then
  begin
    if not (TCustomMaskEdit(Instance).IsMasked) then  // CutToClipboard would call "inherited"
      QClxLineEdit_cut(QClxLineEditH(Instance.Handle))
    else
      TCustomMaskEdit(Instance).CutToClipboard;
  end
  else
  if Instance is TCustomEdit then
    QClxLineEdit_cut(QClxLineEditH(Instance.Handle));
end;

procedure TCustomEdit_Paste(Instance: TWinControl);
  procedure LineEditPaste;
  var
    WValue: WideString;
  begin
    WValue := Clipboard.AsText;
    case THackedCustomEdit(Instance).CharCase of
      ecUpperCase:
        WValue := WideUpperCase(WValue);
      ecLowerCase:
        WValue := WideLowerCase(WValue);
    end;
    QClxLineEdit_insert(QClxLineEditH(Instance.Handle), PWideString(@WValue));
    QClxLineEdit_resetSelection(QClxLineEditH(Instance.Handle));
  end;
begin
  if Instance is TCustomMemo then
    QMultiLineEdit_paste(QMultiLineEditH(Instance.Handle))
  else
  if Instance is TCustomMaskEdit then
  begin
    if not (TCustomMaskEdit(Instance).IsMasked or
       THackedCustomMaskEdit(Instance).ReadOnly) then  // PasteFromClipboard would call "inherited"
      QClxLineEdit_cut(QClxLineEditH(Instance.Handle))
    else
      TCustomMaskEdit(Instance).CutToClipboard;
  end
  else
  if Instance is TCustomEdit then
    LineEditPaste;
end;

// *****************************************************************************

procedure TJvExControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
end;

procedure TJvExControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
end;

procedure TJvExControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;

procedure TJvExControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExControl.DoFocusChanged(Control: TWinControl);
begin
end;

constructor TJvExControl.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  inherited Create(AOwner);
  FHintColor := Application.HintColor;
end;

destructor TJvExControl.Destroy;
begin
  
  inherited Destroy;
end;

procedure TJvExWinControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
end;

procedure TJvExWinControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
end;

procedure TJvExWinControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExWinControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExWinControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExWinControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;

function TJvExWinControl.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := WidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExWinControl.OnFontChanged(Sender: TObject);
var
  FontChangedEvent: QEventH;
begin
  ParentFont := False;
  if Font.Height <> FFontHeight then
  begin
    ScalingFlags := ScalingFlags + [sfFont];
    FFontHeight := Font.Height;
  end;
  FontChangedEvent := QEvent_create(QEventType_FontChanged);
  if FontChangedEvent <> nil then
    QApplication_postEvent(Handle, FontChangedEvent);
end;

procedure TJvExWinControl.DoFontChanged(Sender: TObject);
begin
//  if Assigned(InternalFontChanged) then
//    InternalFontChanged(self);
  FontChanged;
end;

procedure TJvExWinControl.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExWinControl.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExWinControl.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExWinControl.CreateWnd;
begin
  inherited CreateWidget;
end;

function TJvExWinControl.WidgetFlags: integer;
begin
  Result := inherited WidgetFlags or
    integer(WidgetFlags_WRepaintNoErase) or
    integer(WidgetFlags_WMouseNoMask);
end;

function TJvExWinControl.EventFilter(Sender: QObjectH; Event: QEventH): boolean;
begin
  Result := inherited EventFilter(Sender, Event);
  Result := Result or WidgetControl_EventFilter(Self, Sender, Event);
end;

procedure TJvExWinControl.PaintWindow(PaintDevice: QPaintDeviceH);
begin
  WidgetControl_PaintTo(self, PaintDevice, 0, 0);
end;

procedure TJvExWinControl.PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
begin
  WidgetControl_PaintTo(self, PaintDevice, X, Y);
end;

procedure TJvExWinControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExWinControl.DoFocusChanged(Control: TWinControl);
begin
end;

procedure TJvExWinControl.DoBoundsChanged;
begin
end;

procedure TJvExWinControl.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExWinControl.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExWinControl.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExWinControl.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;

constructor TJvExWinControl.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  inherited Create(AOwner);
  FCanvas := TControlCanvas.Create;
  TControlCanvas(FCanvas).Control := Self;
//  InternalFontChanged := Font.OnChange;
  Font.OnChange := OnFontChanged;
  FBevelEdges := [beLeft, beTop, beRight, beBottom];
  DoubleBuffered := True;
  FHintColor := Application.HintColor;
end;

destructor TJvExWinControl.Destroy;
begin

  FCanvas.Free;
  inherited Destroy;
end;

function TJvExWinControl.ColorToRGB(AColor: TColor): TColor;
begin
  Result := QWindows.ColorToRGB(AColor, self);
end;

procedure TJvExWinControl.SetBevelCut(Index: Integer; Value: TBevelCut);
begin
  case Index of
    0: { BevelInner }
      if Value <> FBevelInner then
      begin
        FBevelInner := Value;
        BorderStyleChanged;
      end;
    1: { BevelOuter }
      if Value <> FBevelOuter then
      begin
        FBevelOuter := Value;
        BorderStyleChanged;
      end;
  end;
end;

procedure TJvExWinControl.BorderStyleChanged;
begin
  Invalidate;
end;

procedure TJvExWinControl.SetBevelEdges(Value: TBevelEdges);
begin
  if Value <> FBevelEdges then
  begin
    FBevelEdges := Value;
    BorderStyleChanged;
  end;
end;

procedure TJvExWinControl.SetBevelKind(Value: TBevelKind);
begin
  if Value <> FBevelKind then
  begin
    FBevelKind := Value;
    BorderStyleChanged;
  end;
end;

procedure TJvExWinControl.SetBevelWidth(Value: TBevelWidth);
begin
  if Value <> FBevelWidth then
  begin
    FBevelWidth := Value;
    BorderStyleChanged;
  end;
end;

procedure TJvExWinControl.SetBorderWidth(Value: TBorderWidth);
begin
  if Value <> FBorderWidth then
  begin
    FBorderWidth := Value;
    BorderStyleChanged;
  end;
end;

procedure TJvExWinControl.AdjustClientRect(var Rect: TRect);
var
  BevelSize: Integer;
begin
  inherited AdjustClientRect(Rect);
  InflateRect(Rect, -BorderWidth, -BorderWidth);
  BevelSize := 0;
  if BevelOuter <> bvNone then Inc(BevelSize, BevelWidth);
  if BevelInner <> bvNone then Inc(BevelSize, BevelWidth);
  InflateRect(Rect, -BevelSize, -BevelSize);
end;

procedure TJvExWinControl.Paint;
begin
  WinControl_Paint(self, Canvas);
end;

procedure TJvExWinControl.ColorChanged;
begin
  WidgetControl_ColorChanged(Self);
end;

function TJvExWinControl.GetDoubleBuffered: Boolean;
begin
  Result := FDoubleBuffered;
end;

procedure TJvExWinControl.SetDoubleBuffered(Value: Boolean);
begin
  if Value <> FDoubleBuffered then
  begin
    if Value then
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_NoBackground)
    else
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_PaletteBackground);
    FDoubleBuffered := Value;
  end;
end;

procedure TJvExWinControl.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  CustomControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExGraphicControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
end;

procedure TJvExGraphicControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
end;

procedure TJvExGraphicControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExGraphicControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExGraphicControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExGraphicControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
  

procedure TJvExGraphicControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExGraphicControl.DoFocusChanged(Control: TWinControl);
begin
end;
  
constructor TJvExGraphicControl.Create(AOwner: TComponent);
begin 
  WindowProc := WndProc;
  inherited Create(AOwner);
  FHintColor := Application.HintColor;
  
end;

destructor TJvExGraphicControl.Destroy;
begin
  
  inherited Destroy;
end;
 

function TJvExGraphicControl.GetText: TCaption;
begin
  Result := FText;
end;

procedure TJvExGraphicControl.SetText(const Value: TCaption);
begin
  if Value <> FText then
  begin
    FText := Value;
    TextChanged;
  end;
end;

procedure TJvExGraphicControl.PaintRequest;
begin
  if not Assigned(Parent) then
    Exit;
  Canvas.Start;
  try
    Canvas.Brush.Color := Color;
    Canvas.Brush.Style := bsSolid;
    Canvas.Font.Assign(Font);
    QPainter_setFont(Canvas.Handle, Canvas.Font.Handle);
    QPainter_setPen(Canvas.Handle, Canvas.Font.FontPen);
    QPainter_setBrush(Canvas.Handle, Canvas.Brush.Handle);
    inherited PaintRequest;
  finally
    Canvas.Stop;
  end;
end;

procedure TJvExCustomControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
end;

procedure TJvExCustomControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
end;

procedure TJvExCustomControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExCustomControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExCustomControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExCustomControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
  
function TJvExCustomControl.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := WidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExCustomControl.OnFontChanged(Sender: TObject);
var
  FontChangedEvent: QEventH;
begin
  ParentFont := False;
  if Font.Height <> FFontHeight then
  begin
    ScalingFlags := ScalingFlags + [sfFont];
    FFontHeight := Font.Height;
  end;
  FontChangedEvent := QEvent_create(QEventType_FontChanged);
  if FontChangedEvent <> nil then
    QApplication_postEvent(Handle, FontChangedEvent);
end;

procedure TJvExCustomControl.DoFontChanged(Sender: TObject);
begin
//  if Assigned(InternalFontChanged) then
//    InternalFontChanged(self);
  FontChanged;
end;

procedure TJvExCustomControl.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExCustomControl.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExCustomControl.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExCustomControl.CreateWnd;
begin
  inherited CreateWidget;
end;

function TJvExCustomControl.WidgetFlags: integer;
begin
  Result := inherited WidgetFlags or
    integer(WidgetFlags_WRepaintNoErase) or
    integer(WidgetFlags_WMouseNoMask);
end;

function TJvExCustomControl.EventFilter(Sender: QObjectH; Event: QEventH): boolean;
begin
  Result := inherited EventFilter(Sender, Event);
  Result := Result or WidgetControl_EventFilter(Self, Sender, Event);
end;

procedure TJvExCustomControl.PaintWindow(PaintDevice: QPaintDeviceH);
begin
  WidgetControl_PaintTo(self, PaintDevice, 0, 0);
end;

procedure TJvExCustomControl.PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
begin
  WidgetControl_PaintTo(self, PaintDevice, X, Y);
end;

procedure TJvExCustomControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExCustomControl.DoFocusChanged(Control: TWinControl);
begin
end;
  
procedure TJvExCustomControl.DoBoundsChanged;
begin
end;

procedure TJvExCustomControl.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExCustomControl.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExCustomControl.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExCustomControl.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;

constructor TJvExCustomControl.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  inherited Create(AOwner);
//  InternalFontChanged := Font.OnChange;
  Font.OnChange := OnFontChanged;
  
  DoubleBuffered := True;
  FHintColor := Application.HintColor;
end;

destructor TJvExCustomControl.Destroy;
begin
  
  inherited Destroy;
end;

procedure TJvExCustomControl.ColorChanged;
begin
  WidgetControl_ColorChanged(Self);
end;

function TJvExCustomControl.GetDoubleBuffered: Boolean;
begin
  Result := FDoubleBuffered;
end;

procedure TJvExCustomControl.SetDoubleBuffered(Value: Boolean);
begin
  if Value <> FDoubleBuffered then
  begin
    if Value then
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_NoBackground)
    else
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_PaletteBackground);
    FDoubleBuffered := Value;
  end;
end;

procedure TJvExCustomControl.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  CustomControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExHintWindow.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
end;

procedure TJvExHintWindow.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
end;

procedure TJvExHintWindow.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExHintWindow.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExHintWindow.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExHintWindow.IsRightToLeft: Boolean;
begin
  Result := False;
end;
  
function TJvExHintWindow.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := WidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExHintWindow.OnFontChanged(Sender: TObject);
var
  FontChangedEvent: QEventH;
begin
  ParentFont := False;
  if Font.Height <> FFontHeight then
  begin
    ScalingFlags := ScalingFlags + [sfFont];
    FFontHeight := Font.Height;
  end;
  FontChangedEvent := QEvent_create(QEventType_FontChanged);
  if FontChangedEvent <> nil then
    QApplication_postEvent(Handle, FontChangedEvent);
end;

procedure TJvExHintWindow.DoFontChanged(Sender: TObject);
begin
//  if Assigned(InternalFontChanged) then
//    InternalFontChanged(self);
  FontChanged;
end;

procedure TJvExHintWindow.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExHintWindow.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExHintWindow.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExHintWindow.CreateWnd;
begin
  inherited CreateWidget;
end;

function TJvExHintWindow.WidgetFlags: integer;
begin
  Result := inherited WidgetFlags or
    integer(WidgetFlags_WRepaintNoErase) or
    integer(WidgetFlags_WMouseNoMask);
end;

function TJvExHintWindow.EventFilter(Sender: QObjectH; Event: QEventH): boolean;
begin
  Result := inherited EventFilter(Sender, Event);
  Result := Result or WidgetControl_EventFilter(Self, Sender, Event);
end;

procedure TJvExHintWindow.PaintWindow(PaintDevice: QPaintDeviceH);
begin
  WidgetControl_PaintTo(self, PaintDevice, 0, 0);
end;

procedure TJvExHintWindow.PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
begin
  WidgetControl_PaintTo(self, PaintDevice, X, Y);
end;

procedure TJvExHintWindow.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExHintWindow.DoFocusChanged(Control: TWinControl);
begin
end;
  
procedure TJvExHintWindow.DoBoundsChanged;
begin
end;

procedure TJvExHintWindow.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExHintWindow.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExHintWindow.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExHintWindow.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;
  
constructor TJvExHintWindow.Create(AOwner: TComponent);
begin
  WindowProc := WndProc;
  inherited Create(AOwner);
//  InternalFontChanged := Font.OnChange;
  Font.OnChange := OnFontChanged;
  
  DoubleBuffered := True;
  FHintColor := Application.HintColor;
end;

destructor TJvExHintWindow.Destroy;
begin
  
  inherited Destroy;
end;
  
procedure TJvExHintWindow.ColorChanged;
begin
  WidgetControl_ColorChanged(Self);
end;

function TJvExHintWindow.GetDoubleBuffered: Boolean;
begin
  Result := FDoubleBuffered;
end;

procedure TJvExHintWindow.SetDoubleBuffered(Value: Boolean);
begin
  if Value <> FDoubleBuffered then
  begin
    if Value then
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_NoBackground)
    else
      QWidget_setBackgroundMode(Handle, QWidgetBackgroundMode_PaletteBackground);
    FDoubleBuffered := Value;
  end;
end;

procedure TJvExHintWindow.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  CustomControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExFrameControl.MouseEnter(Control: TControl);
begin
  Control_MouseEnter(Self, Control, FMouseOver, FSavedHintColor, FHintColor);
  inherited MouseEnter(Control);
end;

procedure TJvExFrameControl.MouseLeave(Control: TControl);
begin
  Control_MouseLeave(Self, Control, FMouseOver, FSavedHintColor);
  inherited MouseLeave(Control);
end;

procedure TJvExFrameControl.ParentColorChanged;
begin
  inherited ParentColorChanged;
  if Assigned(FOnParentColorChanged) then
    FOnParentColorChanged(Self);
end;

function TJvExFrameControl.Perform(Msg: Cardinal; WParam, LParam: Longint): Longint;
var
  Mesg: TMessage;
begin
  Mesg.Result := 0;
  if Self <> nil then
  begin
    Mesg.Msg := Msg;
    Mesg.WParam := WParam;
    Mesg.LParam := LParam;
    WindowProc(Mesg);
  end;
  Result := Mesg.Result;
end;

procedure TJvExFrameControl.WndProc(var Msg: TMessage);
begin
  Dispatch(Msg);
end;

function TJvExFrameControl.IsRightToLeft: Boolean;
begin
  Result := False;
end;
  
function TJvExFrameControl.NeedKey(Key: Integer; Shift: TShiftState;
  const KeyText: WideString): Boolean;
begin
  Result := WidgetControl_NeedKey(Self, Key, Shift, KeyText,
    inherited NeedKey(Key, Shift, KeyText));
end;

procedure TJvExFrameControl.OnFontChanged(Sender: TObject);
var
  FontChangedEvent: QEventH;
begin
  ParentFont := False;
  if Font.Height <> FFontHeight then
  begin
    ScalingFlags := ScalingFlags + [sfFont];
    FFontHeight := Font.Height;
  end;
  FontChangedEvent := QEvent_create(QEventType_FontChanged);
  if FontChangedEvent <> nil then
    QApplication_postEvent(Handle, FontChangedEvent);
end;

procedure TJvExFrameControl.DoFontChanged(Sender: TObject);
begin
//  if Assigned(InternalFontChanged) then
//    InternalFontChanged(self);
  FontChanged;
end;

procedure TJvExFrameControl.BoundsChanged;
begin
  inherited BoundsChanged;
  DoBoundsChanged;
end;

procedure TJvExFrameControl.RecreateWnd;
begin
  RecreateWidget;
end;

procedure TJvExFrameControl.CreateWidget;
begin
  CreateWnd;
end;

procedure TJvExFrameControl.CreateWnd;
begin
  inherited CreateWidget;
end;

function TJvExFrameControl.WidgetFlags: integer;
begin
  Result := inherited WidgetFlags or
    integer(WidgetFlags_WRepaintNoErase) or
    integer(WidgetFlags_WMouseNoMask);
end;

function TJvExFrameControl.EventFilter(Sender: QObjectH; Event: QEventH): boolean;
begin
  Result := inherited EventFilter(Sender, Event);
  Result := Result or WidgetControl_EventFilter(Self, Sender, Event);
end;

procedure TJvExFrameControl.PaintWindow(PaintDevice: QPaintDeviceH);
begin
  WidgetControl_PaintTo(self, PaintDevice, 0, 0);
end;

procedure TJvExFrameControl.PaintTo(PaintDevice: QPaintDeviceH; X, Y: integer);
begin
  WidgetControl_PaintTo(self, PaintDevice, X, Y);
end;
  

procedure TJvExFrameControl.CMFocusChanged(var Msg: TCMFocusChanged);
begin
  inherited;
  DoFocusChanged(Msg.Sender);
end;

procedure TJvExFrameControl.DoFocusChanged(Control: TWinControl);
begin
end;
  
procedure TJvExFrameControl.DoBoundsChanged;
begin
end;

procedure TJvExFrameControl.DoGetDlgCode(var Code: TDlgCodes);
begin
end;

procedure TJvExFrameControl.DoSetFocus(FocusedWnd: HWND);
begin
end;

procedure TJvExFrameControl.DoKillFocus(FocusedWnd: HWND);
begin
end;

function TJvExFrameControl.DoPaintBackground(Canvas: TCanvas; Param: Integer): Boolean;
asm
  JMP   DefaultDoPaintBackground
end;
  
constructor TJvExFrameControl.Create(AOwner: TComponent);
begin 
  WindowProc := WndProc; 
  inherited Create(AOwner); 
  FCanvas := TControlCanvas.Create;
  TControlCanvas(FCanvas).Control := Self;
//  InternalFontChanged := Font.OnChange;
  Font.OnChange := OnFontChanged;
  FHintColor := Application.HintColor;
end;

procedure TJvExFrameControl.Painting(Sender: QObjectH; EventRegion: QRegionH);
begin
  WidgetControl_Painting(Self, Canvas, EventRegion);
end;

procedure TJvExFrameControl.Paint;
begin
  WidgetControl_DefaultPaint(self, Canvas);
end;


destructor TJvExFrameControl.Destroy;
begin
  inherited Destroy;
end;

// *****************************************************************************

type
  PBoolean = ^Boolean;
  PPointer = ^Pointer;

function ReadProtectedMemory(Address: Pointer; var Buffer; Count: Cardinal): Boolean;
var
  n: Cardinal;
begin
  Result := ReadProcessMemory(GetCurrentProcess, Address, @Buffer, Count, n);
  Result := Result and (n = Count);
end;

function WriteProtectedMemory(Address: Pointer; const Buffer; Count: Cardinal): Boolean;
var
  n: Cardinal;
begin
  Result := WriteProcessMemory(GetCurrentProcess, Address, @Buffer, Count, n);
  Result := Result and (n = Count);
end;

type
  TJumpCode = packed record
    Pop: Byte; // pop xxx
    Jmp: Byte; // jmp Offset
    Offset: Integer;
  end;

  TOrgCallCode = packed record
    Push: Byte; // push ebx/ebp
    InjectedCode: TJumpCode;
    Jmp: Byte; // jmp Offset
    Offset: Integer;
    Address: Pointer;
  end;

function GetRelocAddress(ProcAddress: Pointer): Pointer;
type
  TRelocationRec = packed record
    Jump: Word;
    Address: PPointer;
  end;
var
  Relocation: TRelocationRec;
  Data: Byte;
begin
  Result := ProcAddress;
 // the relocation table meight be protected
  if ReadProtectedMemory(ProcAddress, Data, SizeOf(Data)) then
  begin
    if Data = $FF then // ProcAddress is in a dll or package
      if ReadProtectedMemory(ProcAddress, Relocation, SizeOf(Relocation)) then
        Result := Relocation.Address^;
  end;
end;

function InstallProcHook(ProcAddress, HookProc, OrgCallProc: Pointer): Boolean;
var
  Code: TJumpCode;
  OrgCallCode: TOrgCallCode;
begin
  ProcAddress := GetRelocAddress(ProcAddress);
  Result := False;
  if Assigned(ProcAddress) and Assigned(HookProc) then
  begin
    if OrgCallProc <> nil then
    begin
      if ReadProtectedMemory(ProcAddress, OrgCallCode, SizeOf(OrgCallCode) - (1 + SizeOf(Integer))) then
      begin
        OrgCallCode.Jmp := $E9;
        OrgCallCode.Offset := (Integer(ProcAddress) + 1 + SizeOf(Code)) -
          Integer(OrgCallProc) -
          (SizeOf(OrgCallCode) - SizeOf(OrgCallCode.Address));
        OrgCallCode.Address := ProcAddress;

        WriteProtectedMemory(OrgCallProc, OrgCallCode, SizeOf(OrgCallCode));
        FlushInstructionCache(GetCurrentProcess, OrgCallProc, SizeOf(OrgCallCode));
      end;
    end;

    if PByte(ProcAddress)^ = $53 then // push ebx
      Code.Pop := $5B // pop ebx
    else
    if PByte(ProcAddress)^ = $55 then // push ebp
      Code.Pop := $5D // pop ebp
    else
      Exit;
    Code.Jmp := $E9;
    Code.Offset := Integer(HookProc) - (Integer(ProcAddress) + 1) - SizeOf(Code);

   { The strange thing is that something overwrites the $e9 with a "PUSH xxx" }
    if WriteProtectedMemory(Pointer(Cardinal(ProcAddress) + 1), Code,
         SizeOf(Code)) then
    begin
      FlushInstructionCache(GetCurrentProcess, ProcAddress, SizeOf(Code));
      Result := True;
    end;
  end;
end;

function UninstallProcHook(OrgCallProc: Pointer): Boolean;
var
  OrgCallCode: TOrgCallCode;
  ProcAddress: Pointer;
begin
  Result := False;
  if Assigned(OrgCallProc) then
  begin
    if OrgCallProc <> nil then
    begin
      if ReadProtectedMemory(OrgCallProc, OrgCallCode, SizeOf(OrgCallCode)) then
      begin
        ProcAddress := OrgCallCode.Address;

        Result := WriteProtectedMemory(ProcAddress, OrgCallCode, 1 + SizeOf(TJumpCode));
        FlushInstructionCache(GetCurrentProcess, ProcAddress, SizeOf(OrgCallCode));
      end;
    end;
  end;
end;

function CallSetFocusedControl(Instance: TCustomForm; Control: TWidgetControl): Boolean;
asm
  dd    0, 0, 0, 0  // 16 Bytes
end;

function SetFocusedControlHook(Instance: TCustomForm; Control: TWidgetControl): Boolean;
var
  Msg: TCMFocusChanged;
begin
  if csFocusing in Instance.ControlState then
    Result := CallSetFocusedControl(Instance, Control)
  else
  begin
    Result := CallSetFocusedControl(Instance, Control);
    if Result then
    begin
      Instance.ControlState := Instance.ControlState + [csFocusing]; // lock
      try
        Msg.Msg := CM_FOCUSCHANGED;
        Msg.Unused := 0;
        Msg.Sender := Control;
        Msg.Result := 0;
        Instance.Broadcast(Msg);
      finally
        Instance.ControlState := Instance.ControlState - [csFocusing];
      end;
    end;
  end;
end;

procedure CutToClipboardHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoClipboardCut
  else
    TCustomEdit_Cut(Instance);
end;

procedure CopyToClipboardHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoClipboardCopy
  else
    TCustomEdit_Copy(Instance);
end;

procedure PasteFromClipboardHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoClipboardPaste
  else
    TCustomEdit_Paste(Instance);
end;

procedure UndoHook(Instance: TWidgetControl);
var
  Intf: IJvEditControlEvents;
begin
  if Supports(Instance, IJvEditControlEvents, Intf) then
    Intf.DoUndo
  else
    TCustomEdit_Undo(Instance);
end;

var
  CallCutToClipboard, CallPasteFromClipboard,
    CallCopyToClipboard, CallUndo: TOrgCallCode;

initialization
  InstallProcHook(@TCustomEdit.CutToClipboard, @CutToClipboardHook,
    @CallCutToClipboard);
  InstallProcHook(@TCustomEdit.CopyToClipboard, @CopyToClipboardHook,
    @CallCopyToClipboard);
  InstallProcHook(@TCustomEdit.PasteFromClipboard, @PasteFromClipboardHook,
    @CallPasteFromClipboard);
  InstallProcHook(@TCustomEdit.Undo, @UndoHook,
    @CallUndo);

finalization
  UninstallProcHook(@CallCutToClipboard);
  UninstallProcHook(@CallCopyToClipboard);
  UninstallProcHook(@CallPasteFromClipboard);
  UninstallProcHook(@CallUndo);
end.

